DSP 20장 - MMU(Memory Management Unit)

메모리 관리장치는 하드웨어 구성요소로서 
프로세싱 유닛, DM4 제어기 또는 다른 버스 요청자에 의해 요청된 메모리이다.




-이니시에이터 내부 (가상)주소를 실제 주소로 변환한다.(즉, 가상메모리 관리)



-이니시에이터가 시스템 메모리의 매핑되지 않은 페이지에 엑세스하는것을 방지한다.



MMU는 다음과 같은것들을 포함한다.


-두개의 Top level MMU
-EDMA 전송 컨트롤러 ( TC 0), 
EDMA전송 컨트롤러(TC1)전용 MMU1
PCle_SS1 및 
PCle_SS2 전용 MMU2

MPU(CoretexR-A15) 하위시스템인 MPU-MMU에 하나의 MMU가 있다.

(이 MMU는 CortexR-A15 프로세서에 통합되어 있다.)



DSP1과 DSP2 서브시스템 안에 각각 2개의 MMU가 들어있다.


EVE에도 들어있다고 써잇는데 여기선 EVE를 지원 안한다고 하니 패스



DMM(Dynamic Memory Manager) 에는 MMU와 비슷한 기능을 하는 PAT(Physical Adress Translator)모듈이 있다.


-15.2 동적메모리 관리자 참조



*DMM
 

들어오는 요청에 초기화 프로그램 기반 우선 순위로 추가
된 요청의 변환을 
타일 변환 및 서브 타일 변환을 수행합니다.
 (???)

쿼드런트 회전 및 미러링과 같은 즉석 기본 변환을 수행합니다.
 

선택적으로 메모리 조각화를 처리하기 위해 대기 시간이 짧은 페이지 기반 변환 제공 

- 메모리 관리 장치 (MMU)



이 챕터에선 다음 MMU에 대해 설명한다.



*시스템 MMU

*DSP MMU

*EVE MMU

*IPU L2 MMU

시스템 MMU와 DSP MMU는 기능면에서 완전히 동일하다.
IPU_L2 MMU는 '바이패스' 기능을 지원하지 않는다는 점이 다른점.


20-1 20-2 는 MMU1과 MMU2의 개요를 보여준다.
요약하면 시스템 MMU1에 대한 요청자(EDMA TC0및 TC1의 읽기 및 쓰기포트에 의해 주어진 요청)
시스템 MMU2에 대한 PCle_SS1 및 PCle_SS2는 선택적으로 해당시스템 MMU를 통해 라우팅될수 있다.


각 요청자가 MMU를 사용하는지의 여부는 제어모듈(CTRL_CORE_SMA_SW7)레지스터 비트 필드를 통해 독립적으로 제어할 수 있다.

이 레지스터는 시스템 초기화 및 정지상태 중에 설정하는 것이 좋다.


MMU루프백 경로가 지정된 요청자에 대해 활성화된 경우 요청은 L3_MAIN 상호연결을 통해 MMU로 라우팅되면 다시 요청된 실제 주소로 L3 인터페이스를 통과한다.

주어진 요청자에 대해 MMU루프백 경로가 비활성화 된 경우 해당 버스요청은 L3_MAIN 상호연결을 통해 요청된 실제 주소로 직접 이동하므로 버스요청 대기시간이 최소화된다.




MMU Intergration


이 섹션에선 클럭,타겟,하드웨어 요청에 대한 정보를 포함하여 장치에서 시스템 MMU를 통합 설명한다.
(DSP,EVE,및 IPU MMU 통합에 대한 내용)


20-3, 20-4는 MMU1, MMU2의 통합에 대해 보여준다.


MMU Discription

MMU Block Diagram


MMU는 외부주소로부터 가상 주소에서 실제 주소로의 변환을 관리한다.


-각 테이블 엔트리는 하나의 인접한 메모리영역의 변환을 설명한다.


-두개의 주요 기능 단위가 MMU에 존재하여 테이블항목을 기반으로 주소변환을 자동으로 제공한다.


20-5는 블록다이어그램에 대한 그림이다.


테이블 워커는 요청된 변환에 대한 올바른 변한 테이블 항목을 자동으로 검색한다.


2레벨 변환이 사용되면 (작은 메모리페이지의 변환을 위해), 테이블 워커는 필요한 2레벨 변환 테이블 항목을 자동으로 읽어온다.


TLB(Translation Look-aside Buffer)는 최근에 사용된 변환 엔트리를 저장하며 변환 테이블의 캐시처럼 작용한다.


MMUAddress Transtlation Process


주소변환이 요청될때마다 (MMU가 활성화된 모든 엑세스에 대해) 

MMU는 변환값이 TLB에 저장되어 있는지의 여부를 먼저 확인한다.

TLB는 변환값을 저장하는 캐시처럼 작용한다.

TLB는 시간이 중요한 데이터를 지체없이 변환할 수 있도록 수동으로 프로그래밍할수도 있다.

요구하는 변환이 TLB에 없다면 테이블 워킹 로직은 변환테이블로부터 이 변환을 검색하고 TLB를 갱신한다.


그 뒤에 주소변환이 수행된다.


그림 20-6은 프로세스를 요약한것이다.


Translation table 


가상주소를 실제주소로 변환하는것은 다음 속성을 정의하는 변한 테이블의 항목을 기반으로 한다.



-주소 변환, 즉 가상 주소와 실제주소간의통신


-엔트리가 변한하는 메모리 영역의 크기

가상주소는 변환테이블을 색인한다. 

각 가상주소는 변환테이블의 정확히 한 항목에 해당한다.


Translation table Hierachy


테이블 기반 주소변환체계를 개발 할 때 가장 중요한 설계 매개변수 중 하나는 


각 변환 테이블 항목에서 설명하는 메모리 페이지 크기이다.


MMU인스턴스는 4KiB 및 64KiB 페이지, 1-MIB 섹션 및 16-MiB 슈퍼섹션을 지원한다.


더 큰 페이지 크기를 사용하는것은 더 작은 반환 테이블을 의미한다.


더 작은 페이지 크기를 사용하면 동적 메모리 할당 및 조각 모음의 효율성이 크게 높아진다.


이것이 많은 운영체제가 4KiB의 메모리 블록에서 작동할 수 있는 이유이다.


그러나 크기가 작을수록 테이블 구조가 더 복잡해진다.


빠른 계산에 따르면 변환 테이블이 하나 인 4 KiB 메모리 페이지를 사용하면 

전체 4-GiB 주소 범위에 100 만 개의 항목이 필요하다.

 
테이블 자체는 32 MiB, 가능하지 않은 크기이다.


그러나 더 큰 페이지를 사용하면 일반적인 OS 메모리 관리의 유연성이 떨어지게된다. 


2 레벨 계층을 구현하면이 두 가지 요구 사항이 조정된다. 


이 계층 구조 내에서 하나의 1 차 레벨 변환 테이블은 1 MiB 메모리 영역을 기반으로 한 변환 특성을 설명한다.


1레벨 변환 표가 지정하는 각 항목

대용량 메모리 섹션의 변환 속성. 


이 메모리 섹션은 1 MiB (섹션) 또는 16 MiB (supersection) 중 하나일 수 있다.

 
이 경우, 모든 변환 매개 변수는 1 레벨 변환 표 항목에 지정

1-MiB 메모리 페이지 내의 더 작은 페이지를 기반으로 
개별 변환 로퍼를 지정하는 두 번째 수준 변환 테이블에 대한 포인터.

 
이 페이지는 64KB (큰 페이지) 또는 4KB (작은 페이지) 일 수 있습니다.

 
이 경우 실제 변환 매개 변수는 두 번째 수준 변환 테이블 항목에 지정.

 
1 레벨 변환 테이블 항목은 2 레벨 변환 테이블의 기본 주소만 지정



이 계층 적 접근 방식은 페이지가 실제로 사용될 때만 

작은 페이지에 대한 추가 변환 정보를 제공해야한다는 것을 의미합니다. 


그림 20-7은 계층 구조를 보여줍니다.

First-level Translation Table


1 차 레벨 변환 테이블은 1-MiB 섹션에 대한 변환 특성을 설명합니다. 


4-GiB 주소 범위를 설명하려면 4096 개의 32 비트 항목 (소위 1 수준 설명자)이 필요합니다.


1 레벨 변환 표 시작 주소는 최소 128 바이트의 표 크기의 배수로 정렬되어야합니다.

 
결과적으로 완전한 4096-entry 테이블에는 최소한 1K 6바이트의 정렬이 필요합니다.

 
즉, 적어도 마지막 14 개의 주소 비트는 0이어야합니다.


1 레벨 변환 테이블의 시작 주소는 소위 변환 테이블 기반에 의해 지정됩니다.

 
테이블은 가상 주소의 상위 12 비트에 의해 인덱싱됩니다.

 
그림 20-8은이 메커니즘을 보여줍니다.



요약하면, 변환 테이블베이스와 변환 테이블 인덱스는 함께 1 레벨 디스크립터 주소를 정의합니다.

 
그림 20-9에는이 주소를 계산하는 데 사용되는 정확한 메커니즘이 요약되어 있습니다.



First-level Discriptor Format
각 1 레벨 디스크립터는 

1-MiB 또는 16-MiB 섹션에 대한 전체 주소 변환을 제공하거나 

4 KiB 또는 64 KiB 페이지에 대한 2 차 레벨 변환 테이블에 대한 포인터를 제공합니다.

 
표 20-4는 1 레벨 설명자 형식을 보여줍니다.





First-level Page Discriptor Format


1MB보다 작은 변환 세분화가 필요한 경우에는 2 단계 변환 프로세스가 사용됨. 


이 경우, 제 1 레벨 블록 기술자는 제 2 레벨 변환 테이블의 시작 어드레스만을 지정.


두 번째 수준 변환 테이블 항목은 실제 변환 속성을 지정합니다.



First level section Discriptor Format


첫 번째 수준 변환 테이블의 각 섹션 설명자는 1-MiB 섹션 또는 16-MiB 슈퍼 섹션에 대한 

전체 변환 속성을 지정합니다.



첫 번째 레벨 변환 테이블의 각 디스크립터는 1 MiB의 메모리를 설명하기 때문에, 


슈퍼섹션 디스크립터는 16 번 반복되어야한다.

 
액세스가 초기화되지 않은 디스크립터를 가리키는 경우 MMU는 예측할 수없는 방식으로 동작합니다.



섹션 및 슈퍼섹션은 첫 번째 수준 변환 테이블의 정보를 기준으로만 변환 할 수 있습니다.

 
그림 20-10은 섹션의 주소 변환 프로세스를 요약 한 것입니다.



슈퍼섹션의 번역은 섹션의 번역과 유사합니다.

 차이점은 슈퍼섹션에 대해서만 31-24 비트가 첫 번째 수준 변환 테이블에 인덱스를 붙이는 것입니다.

 
슈퍼섹션에 대해 16 개의 동일한 연속 항목이 있으므로 

테이블 인덱스의 마지막 4 비트는 암시 적으로 0으로 가정됩니다.



그림 20-11은 supersection에 대한 변환 메커니즘을 보여줍니다.




*2레벨 변환 (Second-level Descriptor Format



세밀한 미세 입자가 요구 될 때, 즉 1 MiB보다 작은 메모리 섹션이 필요할 때 2 레벨 변환이 사용된다.

 
이 경우, 제 1 레벨 디스크립터는 제 2 레벨 변환 테이블의 기본 주소에 대한 포인터를 제공한다.

 
이 두 번째 수준 테이블은 가상 주소의 비트 19에서 12로 인덱싱된다. 



그림 20-12는이 인덱싱 메커니즘을 보여준다.



각 2 차 수준 변환 테이블은 64 KiB (큰 페이지) 또는 4 KiB (작은 페이지) 페이지의 주소 공간 

1 MiB의 변환을 설명한다.

 
그것은 4 KiB를 각각 기술하는 256 개의 2 차 레벨 디스크립터로 구성된다.


대형 페이지의 경우 동일한 디스크립터가 16 번 반복되어야한다.

 
액세스가 초기화되지 않은 디스크립터를 가리키는 경우 

MMU는 예측할 수없는 방식으로 동작합니다.





Second-level Descriptor Format


제 1 레벨 섹션 디스크립터와 마찬가지로, 제 2 레벨 디스크립터는 

크거나 작은 페이지의 변환에 필요한 모든 정보를 제공한다. 



표 20-5는 두 번째 레벨 디스크립터 형식을 보여줍니다.


X로 되어있는 부분이 있는데 0으로 셋팅하면된다고함



그림 20-13은 작은 페이지의 변환 프로세스를 요약한것



대형 페이지의 번역은 작은 페이지의 번역과 유사합니다.

 
차이점은 큰 페이지의 경우 비트 19 ~ 16 만이 두 번째 수준 변환 테이블에 색인을 지정한다는 것입니다.

 
테이블 인덱스의 마지막 4 비트는 큰 페이지에 대해 16 개의 동일한 연속 항목이 있기 때문에 

암시 적으로 0으로 가정됩니다.

 

그림 20-14에서 볼 수 있습니다.




Translation Lookaside Buffer (변환 참조 버퍼)


가상 주소를 실제 주소로 변환하는 것은 MMU를 사용하는 시스템의 각 메모리 액세스에 필요합니다.


이 변환 프로세스를 가속화하기 위해 캐시 또는 TLB가 최근 번역 결과를 보유합니다.


모든 변환에 대해 MMU 내부 논리는 먼저 요청 된 변환이 TLB에 캐시되어 있는지 여부를 확인합니다.

 
번역이 캐시되면이 변환이 사용됩니다. 

그렇지 않으면 변환 테이블에서 변환이 검색되고 TLB가 갱신됩니다. 

TLB가 꽉 차면 항목 중 하나를 교체해야합니다. 

이 항목은 임의로 선택됩니다.


TLB 기본 포인터를 n으로 설정하여 처음 n 개의 TLB 항목 

(여기서 n <총 TLB 항목 수 N)은 
덮어 쓰지 않도록 보호 (잠금) 될 수 있습니다.


 
이 메커니즘을 사용하면 보호되지 않는 항목 만 덮어 쓸 수 있습니다.

 
희생 포인터는 기록 될 다음 TLB 엔트리를 지시한다.

 그림 20-15는
N 개의 TLB 엔트리를 갖는 TLB의 예 (0에서 N-1까지).

 
기본 포인터는 엔트리 0, 엔트리 1 및 엔트리 2를 보호하는 값 "3"을 포함하고 

희생 포인터는 업데이트 될 다음 TLB 엔트리를 가리킨다.



테이블 워킹 로직은 TLB 엔트리를 자동으로 씁니다.

 
엔트리는 또한 수동으로 기록 될 수 있는데, 

일반적으로 시간이 중요한 데이터 액세스의 변환이 TLB에 이미 존재하여 


가능한 한 빨리 실행되도록 보장합니다.

 
이 때 항목을 덮어 쓰지 않도록 항목을 잠궈야 합니다.





TLB Entry Format


CAM (Content Addressable Memory) 부분에는 가상 주소 변환이 TLB에 있는지 확인하는 데 사용되는 

가상 주소 태그가 들어 있습니다.


TLB는 가상 주소 태그로 주소가 지정된 완전 연관 캐시와 같은 역할을합니다. 


CAM 부분에는 보존 된 매개 변수와 유효한 매개 변수뿐만 아니라 

섹션 / 페이지 크기도 포함됩니다.

 
자세한 내용은 MMU_CAM 레지스터 표를 참조하십시오.



RAM (Random Addressable Memory) 부분에는 가상 주소 태그에 속한 주소 변환이 들어 있습니다.

 
자세한 내용은 MMU_RAM 레지스터 표를 참조하십시오.



유효한 매개 변수는 항목이 유효한지 여부를 지정합니다.

 
보존 된 매개 변수는 TLB 플러시 이벤트에서 항목의 동작을 결정합니다.

 
엔트리가 보존 된 것으로 설정되면 TLB가 플러시 될 때,

 즉 MMU_GFLUSH [0] GLOBALFLUSH가 1로 설정된 경우 삭제되지 않습니다. 

보존 된 항목은 수동으로 삭제해야합니다.

 

Section 20.3.1.2.2, 1 단계 변환 표에서는 TLB 항목을 삭제하는 절차를 설명한다.



표 20-17은 TLB entry의 구조를 보여준다.






No Translation (Bypass) Regions 변환 (바이패스)영역 없음



MMU는 주소 변환이없는 최대 4 개의 사용자 프로그래밍 가능 영역을 지원합니다.

 
MMU_BYPASS_REGIONx_ADDR 및 MMU_BYPASS_REGIONx_SIZE 레지스터 (x = 1 ~ 4)로 지정된 영역에 액세스하면 


가상 주소가 실제 주소로 변환되지 않습니다.



MMU 소프트웨어 리셋



소프트웨어 리셋을 수행하려면 MMU_SYSCONFIG [1] SOFTRESET 비트에 1을 씁니다.

 
MMU_SYSSTATUS [0] RESETDONE 비트는 해당 값이 1 일 때 소프트웨어 재설정이 완료되었음을 나타냅니다.


소프트웨어 재설정이 완료되면 MMU_SYSCONFIG [1] SOFTRESET 비트가 자동으로 재설정됩니다.


소프트웨어는 MMU 작업을 수행하기 전에 소프트웨어 재설정이 완료되었는지 확인해야합니다.

 
MMU 인스턴스가 재설정에서 해제되면 해당 TLB는 비어 있고 MMU는 비활성화됩니다.



MMU Power Management
표 20-6에서는 MMU 모듈에서 사용할 수있는 전원 관리 기능에 대해 설명합니다.