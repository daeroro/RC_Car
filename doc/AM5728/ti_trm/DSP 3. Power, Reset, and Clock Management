3. Power, Reset, and Clock Management (PRCM)


<3.1> Device Power Management introduction

파워 매니지먼트는 어느 장치에서나 중요

사용자 만족을 위한 최대한의 퍼포먼스, 사용자의 최대한 디자인 유동성을 위해 (어플리케이션의 요구에따라)


<3.1.1> Device Power-Management Architectiure Building Blocks

파워 매니지먼트 프레임 워크는 3가지 자원으로 구성: clock, power, and voltage
-> 클락 도메인, 파워 도메인, 볼티지 도메인
(도메인은 같은 소스(클락소스, 파워스위치, 볼티지 소스)를 공유하는 모듈의 그룹)

도메인은 policy manager에 의해 관리 (도메인마다 매니저가 있다)


<3.1.1.1> Clock Management

PRCM 모듈이 클락을 관리

(클락)모듈에 전달되는 클락의 특성으로 2가지로 나뉨: interface clocks, functional clocks

* interface clocks 특성

모듈과 (device)interconnect 사이에서 커뮤니케이션
(클락)모듈의 interface 와 register에 공급


* funtional clocks 특성

기능적인 부분에 공급

몇 개의 funtional clock은 의무, 나머지는 옵션

작동하는데 의무적인 것이 필요
옵션은 카메라 같은 것을 사용할 때


<3.1.1.2> Module-Level Clock Management

클락이 활성화(activation) 되거나 닫는 것(gating)을 PRCM 모듈이 관리
그래서 PRCM 모듈은 클락이 언제 활성화 되고 언제 끝나는지 알고 있어야 한다.

PRCM 모듈의 2가지 클락 매니지 먼트

* Master standby protocol (called master moudule)

모듈이 장치 교류에서 상호교류를 시작
(PCRM모듈과 마스터 모듈 사이)

* Slave idle protocol (called slave module) 

모듈이 상호교류를 시작하지 않고 오직 마스터에 의해 시작된 상호교류에 대한 반응만
(PRCM모듈과 슬레이브 모듈 사이)


* Maser standby protocol 자세히

마스터 모듈이 상호교류를 시작
마스터 모듈이 클락(functional and interface)을 활성화하도록 PRCM 모듈에 요청 -> a module wake-up transition
마스터 모듈이 클락이 더 이상 필요없을 때 닫을 것을 요청 -> (마스터 모듈) in stanby mode


[Table 3-1 Master Module Standby Mode Settings]

0x0 Force-standby: 안의 동작과 관계없이, 데이터를 잃을 수 있다. (디버깅 목적)
0x1 No-standby: 클락을 활성화된 상태로 놔둔다. power적으로 효율적이진 않다. (디버깅 목적)
0x2 Smart-standby: 진행중인 상호교류가 있을 때만 standby 신호가 생기고 그렇지 않으면 잠든(idle) 상태 (실제 사용시)
0x3 Smart-standby wake-up-capable mode: 적당한 mwakeup output이 실행될 때만 연관이 있다. (실제 사용시)


[Table 3-2 Mater Module Standby Status]

0x0 모듈이 기능하고 있는 상태
0x1 모듈이 스탠바이 모드일 때


[Table 3-3 마스터 모듈 클락이 가능해지는 조건]

클락도메인이 준비되어 있어야 하고 (AND)
마스터 모듈 스탠바이 요청이 시작되지 않아야 한다. (OR)
마스터 모듈 wake-up 요청이 시작되야 한다. (OR)


* Slave idle protocol 자세히

PRCM모듈이 슬레이브 모듈의 상태를 조절
클락이 닫을 수 있을 때, PRCM모듈이 IDLE 요청으로 슬레이브 모듈에게 알린다.
슬레이브는 요청을 알아차리고 PRCM모듈은 모듈의 클락을 닫는다.
클락이 PRCM모듈에 의해서 닫히면, 슬레이브 모듈을 IDEL 상태

마스터 모듈로 부터 서비스 요청이 오거나, 슬레이브 모듈이 wake-up 이벤트를 받으면 슬레이브 모듈은 깨어나야 한다.
PRCM모듈은 슬레이브 모듈을 위한 클락을 가능하게 하고 IDLE 요청을 중단하면서 일어나라는 신호를 준다.


[Table 3-4 모듈 잠든(idle) 모드 세팅] (Table 3-1과 내용 같음, 스탠바이 상태를 잠든 상태로 바꾸면 된다.)

0x0 Force-idle
0x1 No-idle
0x2 Smart-idle
0x3 Smart-idle wake-up capable mode


[Table 3-5 슬레이브 모듈 idle 상태]

0x0 Funtional: 모든 클락이 활성화
0x1 In transition: 일어나거나 자는 상태로 변하는 것
0x2 Interface idle: 인터페이스 클락은 잔다. 부분적인 기능적인 클락이 사용되고 있을 때 계속 기능한다.
0x3 Full idle: 모두 잔다.


스마트 idle 상태일 때, 슬레이브 모델은 IDLE 요청을 인식한다. 인터페이스 클락과 기능적인 클락의 활동을 감안하여
예를 들어 모듈이 자고 있는 상태에도 기능적인 클락은 활동상태로 남아야 한다면 모듈은 오직 인터페이스 클락만 닫는 조건이라는 것을 고려해서
IDLE 요청을 알아차려야 한다. -> CLOCKACTIVITY setting


[Table 3-6 슬레이브 모듈 클락 활동성 세팅]
    인터페이스 클락   기능적인 클락
0x0     닫힘		닫힘
0x1	활성		닫힘
0x2	닫힘		활성
0x3	활성		활성


[Table 3-7 슬레이브 모듈 모드 세팅 in PRCM]

0x0 Disabled
PRCM모듈이 슬레이브 모듈로 IDLE 요청을 보낸다.
만약 슬레이브 모듈이 요청을 인식했다면 PRCM모듈은 모든 클락을 닫는다.
이 상태에서는 오직 wake-up이벤트에만 반응한다.
 
0x1 Auto
PRCM모듈은 오직 인터페이스 클락만 관리(기능적은 클락은 관리하지 않음)
IDLE 요청도 클락도메인 상호교류를 토대로 자동적으로 한다.
슬레이브 모듈이 잠드는 요청을 인식하면 PRCM모듈은 인터페이스 클락을 닫는다.

0x2 Enabled
PRCM모듈이 두가지 클락을 모두 관리
기능적인 클락은 언제나 활성화
슬레이브 모듈이 잠든는 요청을 인식하면 오직 인터페이스 클락만 닫는다.

0x3 Reserved
가능하지 않음


[Table 3-8 슬레이브 모듈 인터페이스 클락 가능한 조건]

클락도메인이 준비되어 있음 (AND)
슬레이브 잠든 상태가 0x0(fully functional) (OR)
슬레이브 잠든 상태가 0x1(in transition) (OR)
슬레이브 일어나는 요청 발생 (OR)


[Table 3-9 슬레이브 모듈 기능적인 클락 가능한 조건]

클락도메인이 준비되어 있음 (AND)
슬레이브 잠든 상태가 0x0 or 0x1 or 0x2(interface clock is idled) (OR)
슬레이브 일어나는 요청 발생 (OR)


* 모듈이 일어나는 요청

슬레이브 모듈은 인터럽트나 DMA 요청이 발생하면 일어나야 한다. (잠자다가)
깨어나는 능력이 있는 슬레이브 모듈은 깨어나는 요청을 PRCM모듈에게 보낸다.
PRCM모듈은 슬레이브 모듈의 클락을 활성화하고 슬레이브 모듈의 깨어나는 요청을 인식한다.
깨어나는 이벤트가 발생할 때 기능적인 클락이 요구되는 것: synchronous wake-up event
두가지 클락이 다 닫혔을 때 발생하는 깨어나는 이벤트: asynchronous wake-up event

모듈 레벨에서 클락 매니지먼트 상호작용을 PRCM모듈과 개별적인 모듈 사이에서 구성된다.
슬레이브 모듈과 PRCM모듈이 상호작용을 하다가 끝난다고 PRCM이 바로 슬레이브 모듈의 클락을 닫는 것은 아니다.
같은 클락을 아직 활동 중인 다른 모듈과 공유한다. 이 공유하는 클락은 모듈의 활동이 끝날 때까지 필요하다.
결과적으로 PRCM모듈은 클락도메인 레벨에서의 클락 매니지먼트도 제공한다. (같은 클락을 공유하는 모듈들이 클락 도메인)

 
<3.1.1.1.3> 클락 도메인

클락도메인은 클락 신호를 먹고, 같은 클락매니저가 컨드롤 in PRCM모듈
클락도메인은 장치의 파워 소비를 컨트롤 할 수 있다.

장치 안에 여러 클락 도메인이 있다.
클락매니저는 PRCM모듈이 각각의 클락도메인을 활성화시키고 닫을 수 있다.


[표 3-10 클락도메인 기능적인 클락 상태]

0x0 Gated: 활동 안하는 상태
0x1 Active: 활동하는 상태


[표 3-11 클락도메인 인터페이스 클락 상태]

0x0 Gathed
0x1 Active


<3.1.1.1.4> 클락도메인 레벨에서 클락 매니지먼트

클락매니저는 인터페이스 클락(클락도메인 안)을 관리 (하드웨어)
클락매니저는 기능적인 클락(클락도메인 안)을 관리 (소프트웨어)

클락도메인은 3가지 상태로 변한다.


[표 3-12 클락도메인의 클락 상태]
-> 클락도메인의 상태에 따라 일어나는 일

* ACTIVE
모든 슬레이브 모듈이 잠자고 있는 상태에서 벗어난다.
클락도메인의 활성화된 슬레이브 모듈에 모든 의무적인 기능적 클락이 주어진다.
모든 인터페이스 클락도 주어진다.
두가지 클락 모두 클락도메인 안 마스터 모듈에게도 주어진다.
추가적인 클락도 모듈들에게 주어진다.

* IDLE_TRANSITION
클락도메인의 마스터 모듈은 스탠바이 상태이다.
클락도메인의 슬레이브 모듈은 잠잘 요청을 받는다.
사용하고 있는 상태의 슬레이브 모듈의 기능적인 클락은 활성화가 유지된다.
가능한 추가적인 클락도 주어진다.

* INACTIVE
모든 클락이 닫힌 상태이다.
클락도메인의 슬레이브 모듈은 잠잔 상태이고 활동을 하지 않거나 자동으로 조절되게 세팅되어 있다.
클락도메인의 마스터 모듈은 스탠바이 상태
추가적인 클락들도 모두 닫힌 상태


[표 3-13 클락도메인 클락 변화 모드 세팅]

0x0 NO_SLEEP: 하드웨어 조건에 관계없이 자는 변화가 절대 일어나지 않는다.
0x1 SW_SLEEP: 소프트웨어가 자는 변화를 일으킨다. 연관된 하드웨어 조건이 만족될 때 (표 3-15)
0x2 SW_WKUP: 소프트웨어가 클락도메인을 깨우는 변화를 일으킨다. 연관된 하드웨어 조건이 만족될 때 (표 3-14)
0x3 HW_AUTO: 하드웨어가 PRCM모듈을 통해 자동적으로 깨거나 자는 변화를 조절한다. 연관된 하드웨어 조건이 만족될 때 (표 3-14, 3-15)


<3.1.1.1.5> 클락 도메인이 HW_AUTO모드 일 때의 과정
트
데이터시 참고


<3.1.1.1.6> 클락 도메인이 잠/ 일어남

표 3-14상태일 때 클락도메인 매니저가 도메인을 깨우는 변화를 시작

[표 3-14 클락도메인이 일어나는 조건]
(OR)
클락도메인이 SW_WKUP모드로 세팅
클락도메인 내에 하나의 모듈로 부터 하나의 일어나는 요청이 시작되야 한다.
다른 클락도메인으로부터 최소한 하나의 dynamic dependency (역동적인 요인?)이 활성화
다른 클락도메인으로부터 최소한 하나의 static dependency (고정된 요인?)이 활성화
다른 클락도메인으로부터 최소한 하나의 일어나는 dependency (일어나게 하는 요인?)이 활성화

표 3-15상태일 때 클락도메인 매니저가 도메인을 재우는 변화를 시작

[표 3-15 클락도메인이 자는 조건]
(AND)
클락도메인의 모든 마스터 모듈이 스탠바이 상태
클락도메인의 어느 모듈도 일어나는 요청을 하지 않는다.
역동적인 종속, 고정된 종속, 일어나게 하는 종속이 아무것도 없어야 한다.
(OR)
클락도메인이 SW_SLEEP(0x1)이거나 HW_AUTO(0x3)이거나


<3.1.1.1.7> 클락 도메인 dependency(종속? 요인? 의존?)

도메인 의존성은 두 클락도메인의 관계
도메인 A는 도메인 B에 의존한다. 도메인 B의 모듈이 도메인 A의 모듈에 서비스를 제공할 때
하나의 클락 도메인이 두 모듈 사이에서 커뮤니케이션을 하게 할 때 의존성이 존재하는 것.

클락도메인이 제공하는 클락도메인 의존의 타입
(static / dynamic)

* NA/NA: 아무 의존이 존재하지 않는다.
서로 연결되는 길이 존재하지 않는다.

(static부분)
* SW: 소프트웨어 비트로 컨트롤
* 1: 고정된 의존이 항상 가능하다.
* 2: 고정된 의존이 항상 불가능하다.
* NA: 도메인이 다른 도메인에 접근 가능한 시스템 이니시에이터를 가지지 않는다.

(dynamic부분)
* 1..n: 역동적인 의존이 항상 가능하다.
* 0: 역동적은 의존이 항상 불가능하다.
* NA: 두 도메인 모두 OCP 인터페이스와 직접적인 연결이 되지 않았다.


<3.1.1.1.7.1> 정적인 의존

만약 클락도메인 A가 클락도메인 B의 슬레이브 모듈에 접근할 수 있는 마스터 모듈을 가졌다면 -> 클락 도메인 A는 클락 도메인 B와 정적인 의존을 가진다.
도메인 A와 B가 닫힌 상태라면 도메인 A가 PRCM모듈로 부터 일어나는 요청을 받으면 곧 도메인 B도 활성화 된다.
도메인 B는 오직 닫힐 수 있다. 도메인 A가 스탠바이 상태일 때


<3.1.1.1.7.2> 역동적인 의존

클락도메인 A와 B가 공통의 장치 상호연결에 직접적으로 연결되어 있을 때, 클락도메인들은 역동적인 의존을 가진다.
클락 도메인 B는 커뮤니케이션이 시작되면 곧 활성화 된다. PRCM모듈이 두 클락도메인의 모듈 사이의 상호연결의 커뮤니케이션을 보고 있다가 자동적으로 관리


<3.1.1.1.7.3> 일어나게 하는 의존

일어나게 하는 의존은 모듈의 클락도메인 사이에서 생긴다. 어떤 모듈? 일어나는 이벤트와 연관된 서비스를 필요로 하는 다른 모듈의 클락도메인을 향한 일어나는 신호를 가지고 있는 모듈
일어나게 하는 의존의 결과: 모듈의 일어나는 이벤트는 클락도메인 뿐만아니라 서비스하는 모듈의 클락도메인도 활성화한다. 


<3.1.1.2> 파워 매니지먼트

장치모듈의 파워 공급을 켜고 끄는 것을 PRCM모듈이 관리
사용하지 않을 때는 장치 파워 소비를 최소화하기 위해 끈다.
섹션별로 독립적인 파워 커트롤은 PRCM모듈이 다른 섹션에 영향을 주지 않고 특별한 섹션만 켜고 끌 수 있게 한다.


<3.1.1.2.1> 파워도메인

파워도메인은 장치의 섹션이다. 파워매니저와 함께
장치의 다른 부분에 영향을 주지 않고 파워도메인을 켜고 끌 수 있다.

파워도메인은 로직과 메모리 영역으로 나뉜다.

메모리는 메모리 뱅크와 메모리 로직을 포함한다.
로직은 RFFs와 DFFs로 나뉜다.


[표 3-18 파워도메인 로직영역의 상태]
state		Substate
ON		ON-ACTIVE	: 로직이 완전히 충전, 최소한 하나의 닫힌 클락 도메인이 활성화
		ON-INACTIVE	: 로직이 완전히 충전, 모든 클락도메인이 잠든 상태

RETENTION	CSWR		: 로직이 완전히 충전, 모든 클락도메인이 잠든 상태

OFF				: 로직 파워가 꺼진상태, 모든 로직(DFF와 RFF)을 잃는다(저장된 내용은 제외)


RETENTION상태는 유용하다. 내용을 잃지 않고 저전력 잠든 상태로 빠르게 바꿀 수 있다. 필요하면 ON-ACTIVE상태로 바로 올 수 있다.


메모리 어레이, 메모리 로직의 파워 스위치 동작은 소프트웨어 세팅으로 선택된다.
연관된 파워도메인이 ON 파워 상태일 때 메모리 어레이 파워 상태 변화가 시작된다.


[표 3-19 파워도메인 메모리 영역의 상태]

ON: 메모리 어레이에 파워가 들어오고 기능하고 있는 상태
RETENTION: 메모리 어레이에 파워가 충분히 들어오지만 메모리에는 접근하지 못한다.
	   직접적인 retention 신호를 통해 어레이는 retention 상태로 들어간다.
	   메모리 안의 데이터는 항상 유지된다.
OFF: 메모리 어레이 파워가 꺼진다. 메모리 안의 데이터를 잃는다.


<3.1.1.2.2> 모듈 로직과 메모리 내용

로직과 메모리 파워 상태 변화가 일어나면 모듈의 내용을 더이상 유효하지 않다. (리셋이 되도 마찬가지이다)


<3.1.1.2.3> 파워도메인 매니지먼트

파워매니저가 각 파워도메인에 연관되어 있고 도메인 파워 변화를 관리한다.
파워 변화가 생기기 전 모든 하드웨어 조건이 만족되어야 한다.

ON-ACTIVE에서 다른 상태로 변화하려고 할 때 조건: 파워도메인 안에 있는 모든 클락도메인 매니저가 잠든 상태여야 한다.
잠든 상태로 가기 위해서는 하드웨어가 조건을 만족하는 만큼 갈 수 있다. (단계적으로 잠이 들 수 있다)
활성화 상태로 가기 위해서는 항상 바로 간다.


[표 3-20 파워도메인이 일어나는 조건]
(AND)
볼티지 도메인이 켜있다.
(OR)
최소한 하나의 깨어나는 조건이 있어야 한다. 하나의 닫힌(연관된? 연결된?) 기능적인 클락도메인을 위해
파워도메인과 연관된 클락 생성이나 분배를 위한 요청이 있어야 한다.
PRCM모듈 서비스 요청이 있다. (오직 PRCM모듈 로직을 포함한 파워 도메인만)


[표 3-21 파워도메인이 자는 조건]
(AND)
파워도메인 안 모든 기능적은 클락도메인이 잠자는 상태
파워도메인의 클락 생산, 분배가 끝나고 동행하는 입력 클락이 닫힌다.
PRCM모듈 서비스 요청이 없다. (오직 PRCM모듈 로직을 포함한 파워 도메인만)


[표 3-22 파워도메인의 컨트롤과 상태 레지스터]

데이터시트 참고


<3.1.1.3> 볼티지 매니지먼트

볼티지 매니지먼트는 PRCM모듈에서 컨트롤하지 않는다.
모든 OPP 변화는 소프트웨어 어플리케이션에 의해 직접 조정된다.


<3.1.1.3.1> 볼티지 도메인

볼티지 도메인은 PRCM모듈이 컨트롤 할 수도 있고 안할 수도 있다.

PRCM모듈 안에 있는 볼티지 매니저는 한가지 타입이다.
장치의 동작하는 볼티지 범위안에서 특정한 값으로 볼리티 레벨을 조절하기 위해 소프트웨어를 이용한다. -> adaptive voltage scaling (AVS)
볼티지 소스는 각각 있어서 독립적으로 작동한다.


<3.1.1.3.2> 볼티지 도메인 매니지먼트

그림 3-12 로직 볼티지 매니지먼트

그림 3-13 메모리 볼티지 매니지먼트
-> 메모리 도메인이 RETENTION 파워 상태로 변할 때마다 메모리 어레이에 공급되는 볼티지가 자동적으로 스케일이 낮아진다. (PRCM 하드웨어)


<3.1.1.3.3> AVS 개요

SmartReflex -> 파워 매니지먼트 테크닉
활성화 파워 소비를 줄이기 위해서 사용, 최상의 파워 퍼포먼스를 갖게 해준다.

그림 3-15 SmartReflex 볼티지 컨트롤 그림

데이터시트 참고


<3.1.1.3.3.1> AVS Class 0 볼티지 컨트롤

모든 디바이스로 가는 파워 소비를 평균화? 하는 것을 시도한다
각 AVS의 최상의 볼티지는 eFuse 장치(레지스터)에 적혀있다.


<3.1.2> 파워 매니지먼트 테크닉

<3.1.2.1> 스탠바이 낭비 매니지먼트 (SLM)

파워 낭비를 줄여 스탠바이 파워 소비를 줄이기 위한 테크닉


<3.1.2.2> 역동적인 볼티지와 프리퀀시 스케일링 (DVFS)

시스템이 잠자는 시간을 최소화한다.
일이 끝마칠 때까지 파워 소비를 줄이기 위한 방법, 주어진 시간을 충분히 쓰도록 한다.

그림 3-16 DVFS를 썼을 때와 안 썼을 때, 소비된 에너지 비교

데이터시트 참고

DVFS를 쓸 때, 동작하는 프리퀀시를 최상의 레벨로 줄인다. 일을 4초동안 하게 된다. 파워소비는 줄게 된다.


<3.1.2.3> 역동적인 파워 스위칭 (DPS)

장치의 파워 소비를 줄이기 위한 테크닉 (DVFS와 같다)
DVFS는 역동적이고 낭비되는 파워 소비를 줄인다면 DPS는 낭비되는 파워 소비만 줄인다.

시스템이 동작하고 있는 시간에 높고 낮은 소비 시스템 파워모드를 바꾼다.
DPS는 리얼타임 어플리케이션이 이벤트를 기다리고 있는 시간에 유용하다.
잠드는 구간을 최대화해서 파워 소비를 줄인다.

그림 3-17 DPS 할 때와 안할 때, 소비된 에너지 비교

데이터시트 참고

DPS를 안할 때, 잠든 상태에서 낭비가 생겼다. DPS를 하면 낭비가 없어진다.
단, 시스템 파워 모드를 바꿀 때 정보를 저장해야 한다. 그래서 overhead부분이 생긴다.


<3.1.2.4> 알맞은 볼티지 스케일링 (AVS, SmartReflex)

최상의 파워 퍼포먼스로 가게 한다.


<3.1.2.5> 알맞은 바디 바이어스 (ABB)

트랜지스터 바디 바이어스 테크닉은 FBB를 위한 부품, 작동 클락 프리퀀시를 올려주기 위해 (더 높은 OPP에서 동작을 위해) -> ABB는 알맞은 클락 프리퀀시를 찾는게 아닐까?


<3.1.2.6> SR3-APG (자동적인 파워 닫음)

낭비를 줄이기 위해 사용


<3.1.2.7> 파워 매니지먼트 조합

작동 조건에 따라 효과적인 조합이 있다.

그림 3-18

데이터시트 참고

* AVS
볼티지를 알맞게 맞춘다.
온도 베리에이션을 보상한다.
가능한 어플리케이션 퍼포먼스를 최대로 해준다.

* DVFS
어플리케이션 퍼포먼스 요구가 다양할 때

* DPS
낮은 파워 모드에서도 적용된다.

* DVFS + DPS
더 낮은 작동 프리퀀시가 일 완료 시간을 증가시키고 잠드는 시간을 줄인다.

<3.1.2.7.1> DPS vs SLM

그들의 작동되는 타임스케일이 다르다.

* DPS
DPS로 바뀌는 지연시간이 작아야 한다.
디바이스 퍼포먼스의 질을 떨어뜨리지 않는다.
깨어나는 이벤트는 어플리케이션과 관계

* SLM
SLM으로 바뀌는 시간이 좀 더 길다. (유저의 반응속도보다는 빠르다)
깨어나는 이벤트는 유저와 관계
