19장.VIM


19.1 개요

(참고자료 : http://recipes.egloos.com/4988641)
VIM (vectored interrupt manager)은 장치에있는 많은 인터럽트 소스를 우선 순위 지정하고 제어하기위한 하드웨어 지원을 제공합니다.
인터럽트는 정상적인 프로그램 실행 흐름 이외의 이벤트로 인해 발생합니다.
일반적으로 이러한 이벤트는 중앙 처리 장치 (CPU)에서 적시에 응답해야하므로 인터럽트가 발생하면 CPU가 실행을 일반 프로그램 흐름에서 인터럽트 서비스 루틴 (ISR)으로 전환합니다.

*ISR : MCU가 인터럽트에 걸리면 실행주소가  IRQ 또는  FIQ로 바뀌는데 그  Vactor에는 실제로 핸들러로 분기하기 위한 코드가 들어잇는데 Handler내부에는 여러종류의 인터럽트가 있는데 그 각각의 인터럽트에 따른 응답이 다른 것을 인터럽트 서비스 루틴 (ISR)이라고 부른다.

VIM 모듈에는 다음과 같은 기능이 있습니다.

? 안전을 위한 Dual VIM
? 레지스터 벡터 인터럽트 및 하드웨어 벡터 인터럽트 모드 모두에서 127 개의 인터럽트 채널을 지원합니다.
       - IRQ 벡터를 CPU VIC 포트에 직접 제공합니다.   (참고자료 :http://recipes.egloos.com/tag/irq/page/1)
       -레지스터를 통해 FIQ / IRQ 벡터를 제공합니다.
       -인터럽트 요청 라인에 대해 프로그래밍 가능한 우선 순위 및 활성화 제공
? 가장 빠른 IRQ 발송을 위해 직접적인 하드웨어 디스패치 메커니즘을 제공합니다.
? 이전 세대 TI 프로세서와 역 호환성을위한 두 가지 소프트웨어 디스패치 메커니즘 제공.  
? Index interrupt
? Register vectored interrupt
? ECC(Error Code Correction) 소프트 오류에 대한 보호 된 벡터 인터럽트 테이블.

ECC : 에러코드로부터 보호 하는 코드?
디스패치 : Ready상태에서 Running 으로 가는 과정을 dispatch라고 함.
Ready Queue에 놓이면 일단 우선권이  먼저 Dispatch우선순위가 없으며 FIFO방식으다로 Dispatch 한다.



19.2 Dual VIM for Safety (안전을 위한 Dual VIM)

그림 19-1에는 Dual VIM for Safety의 블록 다이어그램이 나와 있습니다.
일반적인 원인 오류 가능성을 줄이기 위해 VIM 모듈은 두 코어의 두 사이클 지연 작동의 이중 CPU 체계를 모방합니다.
이 경우, 두 번째 인스턴스에 대한 MMR (메모리 매핑 레지스터) 인터페이스는 2 사이클 씩 지연됩니다.
마찬가지로 인터럽트 입력도 두 번째 인스턴스까지 두 사이클만큼 지연됩니다.

VIM1의 CPU 인터럽트 인터페이스에 대한 출력 포트의 "2 사이클"지연 버전 세트가 별도로 제공됩니다.
이것은 CPU 비교 모듈 (CCM)의 비교 입력 값 중 하나로 사용됩니다.
VIM2의 CPU 인터페이스 신호는 CCM의 두 번째 입력 세트로 사용됩니다.

VIM2는 VIM1과 동일한 주소 공간을 사용합니다.
LockStep 모드 동안 VIM1 (인터럽트 벡터 테이블 포함)에 대한 쓰기 작업은 VIM2로도 라우팅되어 보조 인스턴스가 첫 번째 인스턴스와 정확히 동일하게 프로그래밍되고 비교 진단 지원을 제공합니다.
VIM1 인터럽트 벡터 테이블을 자동 초기화 모드에서 VIM2 인터럽트 벡터 테이블이 초기화됩니다.
이 모드에서 VIM의 읽기는 VIM1 데이터 만 반환합니다 .VIM2 레지스터와 인터럽트 벡터 테이블은 잠금 모드에서 읽을 수 없습니다.

19.3 Device Level Interrupt Management (디바이스 레벨 인터럽트 관리)

그림 19-2는 디바이스 레벨 인터럽트 처리의 블록 다이어그램을 보여줍니다.
주변 장치 내에서 이벤트가 발생하면 주변 장치는 VIM에 인터럽트 요청을합니다
그런 다음 VIM은 주변 장치의 요청에 우선 순위를 지정하고 가장 높은 인터럽트 서비스 루틴 (ISR) 주소를 CPU에 제공합니다.
마지막으로 CPU는 ISR의 해당 주소에서 ISR 명령 실행을 시작합니다.
19.3.1 절부터 19.3.3 절까지는이 세 단계에 대한 추가 세부 정보를 제공합니다.


19.3.1 Interrupt Generation at the Peripheral( 주변 장치에서의 인터럽트 생성)

인터럽트 생성은 주변 모듈 내에서 이벤트가 발생할 때 시작됩니다.인터럽트 가능 이벤트의 예로는 타이머 모듈 내의 카운터 만료, 통신 모듈에서의 문자 수신 및 아날로그 - 디지털 컨버터 (ADC) 모듈에서의 변환 완료 등이 있습니다.
일부 장치 주변 장치는 둘 이상의 인터럽트 요청 라인에서 인터럽트를 요청할 수 있습니다.

인터럽트는 이벤트가 발생할 때 항상 생성되는 것은 아닙니다. 주변 장치는 이벤트 발생에 따라 VIM에 인터럽트 요청을해야합니다.
일반적으로 주변 장치에는 다음이 포함됩니다.
? 이벤트 발생을 나타내는 각 이벤트에 대한 인터럽트 플래그 비트.
? 이벤트 발생으로 인해 VIM에 대한 인터럽트 요청이 발생할지 여부를 제어하는 인터럽트 활성화 비트.


19.3.2 Interrupt Handling at the CPU(CPU에서의 인터럽트 처리)
https://memo.naver.com/#{"sAction"%3A"LEFT_LIST"%2C"htParams"%3A{"sFilter"%3A"ALL"%2C"nPage"%3A1%2C"nListNum"%3A"095115"%2C"nMemoSeq"%3A757022}}

ARM CPU는 인터럽트 요청에 대해 고속 인터럽트 요청 (FIQ)과 일반 인터럽트 요청 (IRQ)의 두 가지 벡터를 제공합니다. FIQ는 IRQ보다 우선 순위가 높으며 FIQ 인터럽트는 IRQ 인터럽트를 방해 할 수 있습니다.(p.80)

NOTE:
Cortex-R4F / R5F에 구현 된 FIQ는 NMFI (Non-Maskable Fast Interrupt)입니다.
FIQ가 활성화되면 (CPSR의 F 비트를 지움으로써) CPSR의 F 비트를 설정하여 비활성화 할 수 없습니다.
리셋 또는 FIQ만이 CPSR의 F 비트를 설정할 수 있습니다.
하드웨어로 비 마스킹 가능한 FIQ는 재진입이 불가능합니다.
(참고쟈료 : https://kldp.org/node/124651)

재설정 (전원 재설정 또는 웜 재설정) 후 FIQ 및 IRQ가 모두 비활성화됩니다.
CPU는 CPSR (현재 프로그램 상태 레지스터) 내에서 이러한 인터럽트 요청 채널을 개별적으로 활성화 할 수 있습니다.
CPU에서 FIQ (비트 6) 및 IRQ (비트 7) 인터럽트 요청을 활성화하려면 CPSR 비트 6 및 7을 지워야합니다.
CPSR은 권한 모드에서만 쓸 수 있습니다. 예 19-2는 CPQR을 통해 IRQ 및 FIQ를 활성화하는 방법을 보여줍니다.

CPU가 인터럽트 요청을 받으면 CPSR 모드 필드가 FIQ 또는 IRQ 모드로 변경됩니다.
IRQ 인터럽트가 수신되면 CPU는 CPSR 비트 7을 설정하여 다른 IRQ 인터럽트를 비활성화합니다.
FIQ 인터럽트가 수신되면 CPU는 CPSR 비트 6 및 7을 설정하여 IRQ 및 FIQ 인터럽트를 비활성화합니다.

CPSR 비트 7에 1을 쓰면 CPU의 IRQ가 비활성화됩니다. 그러나 CPSR 비트 6에 1을 쓰면 변경되지 않습니다.
예 19-2는 CPSR을 통해 IRQ를 비활성화하는 방법을 보여줍니다.


*CPSR : 내부동작을 모니터링하고 제어하기위해 사용하는 것.
*CPSR (책에 나와잇는것 p.83참조) : 레지스터이기는 하지만, r0~ r1레지스터와는 다르다 . 약자는 "Cuttent Program Status Register"의 약어로, 현재 실행되는 프로그램의 상태를 담고 있는 중요한 레지스터이며 계속 업에디트 된다

19.3.3 Software Interrupt Handling Options(소프트웨어 인터럽트 처리 옵션)

이 장치는 소프트웨어가 인터럽트를 처리 할 수있는 세 가지 다른 가능성을 지원합니다

1.인덱스 인터럽트 모드 (TMS470R1x 레거시 코드와 호환) CPU가 인터럽트를 수신 한 후 CPU는 0x18 (IRQ) 또는 0x1C (FIQ)로 분기하여   주 ISR을 실행합니다.
메인 ISR 루틴은 인터럽트 소스를 결정하기 위해 오프셋 레지스터 (IRQINDEX, FIQINDEX)를 읽습니다.
이 모드는 TMS470R1x (CIM) 모듈과 호환되며 동일한 인터럽트 레지스터를 제공합니다.
레거시 코드를 재사용해야 TMS470R1x 패밀리에서 포팅 할 때이 모드를 사용할 수 있습니다.
그러나 가져온 소프트웨어는 VIM 개선의 이점을 얻지 못합니다.
레거시 소프트웨어를 포팅하려면 0x18 (IRQ) 또는 0x1C (FIQ)의 인터럽트 벡터가 소프트웨어 인터럽트 테이블의 분기 문일 필요가 있습니다
소프트웨어 인터럽트 테이블은 벡터 오프셋 레지스터 (FIQ 인터럽트의 경우 FIQINDEX [7 : 0] 및 IRQ 인터럽트의 경우 IRQINDEX [7 : 0])에서 보류중인 인터럽트를 읽습니다.
보류중인 모든 인터럽트는 INTREQ 레지스터에서 볼 수 있습니다.
예 19-4는이 모드에서 짧은 대기 시간으로 FIQ에 응답하는 방법을 보여줍니다.

2.벡터화 된 인터럽트 등록 (벡터 주소를 응용 프로그램에 자동으로 제공) 인터럽트를 활성화하기 전에 응용 프로그램 소프트웨어는 인터럽트 벡터 테이블 (VIM RAM)도 초기화해야합니다.
VIM이 인터럽트를 수신하면 인터럽트 벡터 테이블에서 ISR의 주소를로드하고 인터럽트 벡터 레지스터 (IRQ 인터럽트의 경우 IRQVECREG, FIQ 인터럽트의 경우 FIQVECREG)에 저장합니다.
인터럽트가 CPU에 수신 된 후 CPU는 0x18 또는 0x1C (IRQ 또는 FIQ 벡터)에있는 명령어를 실행하여 인터럽트 벡터 레지스터에서 ISR (인터럽트 벡터)의 주소를로드합니다.
예제 19-3에서는이 모드를 사용하는 예외 벡터의 구성을 보여줍니다.

3.하드웨어 벡터 방해 인터럽트 (자동으로 ISR, IRQ로 디스패치) 인터럽트를 활성화하기 전에 응용 프로그램 소프트웨어는 각 인터럽트 채널에 대한 ISR을 가리키는 인터럽트 벡터 테이블 (VIM RAM)을 시작해야합니다.
인터럽트 (IRQ)가 CPU에 의해 수신 된 후 CPU는 0x18로 분기하는 대신 VIM (VIC 포트)이있는 인터페이스에서 직접 ISR의 주소를 읽습니다.
CPU가 ISR로 직접 분기합니다.
CP15 R1 레지스터의 벡터 인 에이블 (VE) 비트를 설정하여 하드웨어 벡터 방해 인터럽트 동작을 명시 적으로 활성화해야합니다.
이 비트는 0으로 재설정되므로 재설정 후 기본 상태는 이전 ARM CPU와 역 호환됩니다.
예제 19-1은 하드웨어 기반 인터럽트를 활성화하는 방법을 보여줍니다.

NOTE :  이 모드는 FIQ에는 사용할 수 없습니다.

4.소프트웨어 기반 우선 순위 디코딩 방식 응용 프로그램이 하드웨어 벡터 기능 대신 소프트웨어 기반 인터럽트 우선 순위 디코딩 방식을 사용하는 경우 이전 장치에서는 필요하지 않은 추가 단계가 있습니다.
이 버전의 VIM은 주변 장치에 의해 생성 된 인터럽트 요청을 보유합니다. 소프트웨어가 소스 모듈 (예 : RTI, GIO 등)의 인터럽트 조건을 지우면 VIM에서 인터럽트 요청을 추가로 제거해야합니다.
이것은 IRQVECREG 레지스터 (섹션 19.9.15) 또는 FIQVECREG 레지스터 (섹션 19.9.16)를 읽거나 VIM의 INTREQ (i) 비트 (섹션 19.9.10)에 1을 쓰는 방법으로 수행 할 수 있습니다.
벡터를 읽을 때 VIM의 인터럽트 요청 비트가 자동으로 지워지므로 앞의 세 가지 방법 중 하나를 사용하면 필요하지 않습니다.


19.4 Interrupt Handling Inside VIM (VIM 내부 인터럽트 처리 )

VIM 내부의 인터럽트 처리 블록 다이어그램은 그림 19-3에 나와 있습니다.


19.4.1 VIM Interrupt Channel Mapping  (VIM인터럽트 채널 맵핑)


VIM은 128 개의 인터럽트 채널 (팬텀 인터럽트 포함)
주변 모듈에서 인터럽트 채널로의 VIM 인터럽트 요청 배열의 블록 다이어그램은 그림 19-4에 나와 있습니다.
각 인터럽트 채널 (CHANx)에는 대응하는 매핑 레지스터 비트 필드 (CHANMAPx [6 : 0])가 있습니다.
이 매핑 레지스터는 각 VIM 인터럽트 요청을 매핑하는 인터럽트 채널을 결정합니다.
이 방식을 사용하면 동일한 요청을 여러 채널에 매핑 할 수 있습니다.
각 FIQ 및 IRQ의 번호가 낮은 채널이 우선 순위가 높습니다.
VIM의 프로그래밍 기능으로 소프트웨어가 인터럽트 우선 순위를 제어 할 수 있습니다.



NOTE : 
CHAN0와 CHAN1은 하드 연결되어 있습니다.
INT_REQ0 및 INT_REQ1은 다시 매핑 할 수 없습니다.


NOTE :  CHAN 127
CHAN127에는 전용 인터럽트 벡터 테이블 엔트리가 없습니다. 따라서 CHAN127은 다른 INT_REQ로 재 매핑되어서는 안됩니다 (INT_REQ127은 장치 수준에서 예약 됨).

리셋 상태에서 VIM은 시스템의 모든 인터럽트 요청을 해당 인터럽트에 매핑합니다
채널. 그림 19-5는 재설정 후의 기본 상태를 보여줍니다.

그림 19-6은 VIM INT2가 채널 2와 4 모두에 다시 매핑되고 INT3이 채널 3에 매핑되는 것을 보여줍니다.

NOTE :
INT2를 채널 2와 채널 4에 매핑하고 INT3을 채널 3에 매핑하면 소프트웨어가 ENABLE 레지스터 (REQENASET 및 REQENACLR)를 변경하여 우선 순위를 동적으로 변경할 수 있습니다. 채널 2가 활성화되면 우선 순위는 다음과 같습니다.
1.   INT 0
2.   INT 1
3.   INT 2
4.   INT 3

채널 2를 사용하지 않도록 설정하면 우선 순위가 다음과 같이됩니다.

1.   INT 0
2.   INT 1
3.   INT 2
4.   INT 3

19-5.
NOTE : CHAN0 및 CHAN1은 INT_REQ0 및 INT_REQ1에 하드웨어로 연결되어 있으므로 다시 매핑 할 수 없습니다.

19-6.
NOTE : CHAN0 및 CHAN1은 INT_REQ0 및 INT_REQ1에 하드웨어로 연결되어 있으므로 다시 매핑 할 수 없습니다.





19.4.2 VIM Input Channel Management (VIM 입력 채널 관리)

그림 19-7에서 볼 수 있듯이 VIM은 채널별로 채널을 활성화합니다 (REQENASET드 및 REQENACLR 레지스터에서).
사용되지 않는 채널은 가짜 인터럽트를 방지하기 위해 가려 질 수 있습니다.

NOTE : 
인터럽트 ENABLE 레지스터는 INTREQ 값에 영향을주지 않습니다.

                                            19-7. Interrupt Channel Management.

기본적으로 인터럽트 CHAN0은 ESM (오류 신호 모듈) 상위 레벨 인터럽트에 매핑되고 CHAN1은 다른 NMI 용으로 예약됩니다. 안전상의 이유로이 두 채널은 FIQ에만 매핑되며 ENABLE 레지스터를 통해 비활성화 할 수 없습니다.

NOTE : NMI Channel
채널 0과 채널 1은 REQENASET / REQENACLR 비트에 의해 마스크 가능하지 않으며 두 채널 모두 FIQ / NMI 요청 라인 (FIRQPR0 및 FIRQPR1은 아무 효과가 없음)으로 배타적으로 *라우팅됩니다.

*라우팅 : 목적지까지 갈 수 있는 여러 경로중에 한가지 경로로 설정해주는 방법 및 과정

VIM은 프로그래밍 된 우선 순위 체계에 따라 수신 된 인터럽트의 우선 순위를 지정합니다.
VIM은 하나의 IRQ와 하나의 FIQ를 동시에 두 개의 인터럽트 요청을 CPU에 보낼 수 있습니다.
CPU 수준에서 두 가지 인터럽트 유형이 모두 활성화되면 FIQ가 더 높은 우선 순위를 가지며 먼저 처리됩니다.
채널 0과 1을 제외한 각 인터럽트 채널은 FIQ 또는 IRQ 요청을 CPU (FIRQPR 레지스터에 있음)로 보내도록 할당 될 수 있습니다.

VIM은 가장 낮은 번호의 활성 채널 (각 FIQ 및 IRQ 클래스에 있음)을 CPU에 보내는 기본 우선 순위 지정 체계를 제공합니다.
인터럽트의 FIQ 및 IRQ 클래스 내에서 가장 낮은 우선 순위의 인터럽트가 가장 높은 우선 순위를 갖습니다.
채널 번호는 CHANMAPx 레지스터를 통해 프로그래밍 할 수 있습니다.

VIM은 가장 높은 활성 IRQ에 해당하는 벡터를 생성 한 후 인터럽트 클래스에 따라 FIQINDEX 또는 IRQINDEX 레지스터를 업데이트합니다. 그런 다음 벡터 값을 사용하여 인터럽트 벡터 테이블에 액세스하여 해당 ISR의 주소를 가져옵니다.
요청이 FIQ 클래스 인터럽트 인 경우 인터럽트 벡터 테이블에서 읽은 주소가 FIQVECREG 레지스터에 기록됩니다.
요청이 IRQ 클래스 인터럽트 인 경우 주소는 IRQVECREG 레지스터에 기록되고 CPU의 VIC 포트에 배치됩니다 (하드웨어 벡터 인터럽트가 활성화 된 경우).

새로운 우선 순위 인터럽트 라인이 활성화되면 모든 인터럽트 레지스터가 업데이트됩니다.



19.5 Interrupt Vector Table (VIM RAM)

인터럽트 벡터 테이블은 ISR의 주소를 저장합니다. 레지스터 벡터화 인터럽트 및 하드웨어 벡터 인터럽트 동안 VIM은 벡터 값을 사용하여 인터럽트 벡터 테이블에 액세스하여 해당 ISR의 주소를 가져옵니다.

안전상의 이유로 인터럽트 벡터 테이블에는 소프트 오류로 인한 손상을 나타 내기 위해 ECC에 의한 보호 기능이 있습니다.
ECC 기법은 메모리 액세스를 기반으로하는 연속 백그라운드 검사로 구현됩니다.
VIM 내부의 ECC 로직은 단일 비트 오류 수정 및 이중 비트 오류 감지 (SECDED)를 지원합니다.
섹션 19.5.1에서 섹션 19.5.4는 ECC가 인터럽트 벡터 테이블에서 작동하는 방법을 설명합니다.



19.5.1 Interrupt Vector Table Operation(테이블 연산)

인터럽트 벡터 테이블은 32 비트의 128 워드로 구성됩니다.
그림 19-8은 인터럽트 메모리 매핑을 보여줍니다. 테이블 기본 주소는 0xFFF82000입니다.


NOTE : 
인터럽트 벡터 테이블에는 128 개의 항목, 하나의 팬텀 벡터 및 127 개의 인터럽트 채널 만 있습니다. 채널 127에는 전용 벡터가 없으므로 사용하지 않아야합니다.

32 비트 ISR 주소 당 7 비트의 ECC가 있습니다. 인터럽트 벡터 테이블에 쓰기가 수행되면 ECC 비트가 32 비트 워드에 대해 계산되고 VIM에서 ECC가 활성화 된 경우 인터럽트 벡터 테이블의 해당 ECC 영역에 기록됩니다.

NOTE :
ECC가 필요한 경우 인터럽트 벡터 테이블에서 32 비트 쓰기 / 읽기 액세스 만 허용됩니다.
비 32 비트 액세스는 ECC 오류를 초래할 수 있습니다.

CPU 또는 VIM에서 읽기가 발생하면 VIM은 인터럽트 벡터 테이블에서 오는 데이터로부터 ECC 비트를 계산하고이를 테이블에 저장된 알려진 양호한 ECC 값과 비교합니다.
데이터에서 단일 비트 오류가 감지되면 SECDED 블록이이를 자동으로 수정합니다.
읽은 데이터는이 경우 수정 된 것입니다.
이중 비트 오류가 감지되면 읽기 데이터는 정정되지 않은 데이터가됩니다.
데이터 및 ECC 비트의 액세스는 동일한 클럭 사이클에서 수행된다.

이중 비트 오류 (DBE) 및 단일 비트 오류 (SBE) 이벤트는 ECC 기능이 ECCENA 필드에 의해 활성화 된 경우에만 생성됩니다.
SBE 이벤트시 데이터의 수정은 EDAC_MODE 필드가 활성화 된 경우에만 수행됩니다.
모든 이중 비트 오류는 ESM 모듈에 플래그 아웃되고 ECCSTAT 레지스터의 UERR 플래그로 플래그됩니다.
UERR이 감지 된 데이터의 주소도 UERRADDR 레지스터로 저장됩니다

모든 단일 비트 오류는 ECCSTAT 레지스터의 SBERR 플래그에 등록되며 해당 주소는 SBERRADDR 레지스터로 캡처됩니다. ECCCTL 레지스터의 SBE_INT_EN 필드가 값을 활성화하도록 설정된 경우 ESM 모듈에 플래그가 지정됩니다.

인터럽트 벡터 테이블은 수정할 수없는 오류 (예 : DBE)를 가질 수 있으므로 FBVECADDR 레지스터는 IRQVECREG 및 FIQVECREG의 VIC 포트에 인터럽트 벡터 테이블 내용을 복구 할 수있는 ISR의 폴백 주소를 제공합니다.
예측할 수없는 위치로의 분기를 피하기 위해 인터럽트 벡터 테이블에서 인터럽트를 초기화하기 전에 FB_VECADDR 레지스터를 설정해야합니다..

ECCSTAT가 CPU에 의해 지워지면 정상 작동이 복원됩니다.
ECCSTAT를 지우기 전에 VIM의 내용을 복원하는 것이 좋습니다.


19.5.2 VIM ECC Syndrome

VIM ECC는 ECCCTL 레지스터의 ECCENA 비트에 의해 제어됩니다.
재설정 후 SECDED 기능이 비활성화됩니다.
SECDED 기능은 ECCCTL 레지스터의 ECCENA [3 : 0] 비트 필드에 0xA (1010b)를 기록하여 활성화 할 수 있습니다.

ECC 생성은 표 19-1과 표 19-2에 표시된대로 ECC 증후군 테이블에 따라 수행됩니다.
각각의 ECC 비트는 데이터 워드의 'XOR'된 비트의 패리티를 생성함으로써 형성되는 반면, ECC 비트 2 및 3은 짝수 패리티이고 다른 비트는 홀수 패리티


19.5.3 Interrupt Vector Table Initialization (초기화)

리셋 후에는 ECC 비트를 포함한 인터럽트 벡터 테이블 내용이 초기화되지 않습니다.
따라서 해당 인터럽트 채널을 활성화하기 전에 먼저 인터럽트 벡터 테이블을 초기화해야합니다. 이 작업은 하드웨어 초기화 메커니즘 (아키텍처 개요 장)을 사용하여 수행하거나 소프트웨어로 알려진 값을 인터럽트 벡터 테이블에 기록하여 수행 할 수 있습니다.
ECC가 필요한 경우 ECC 기능이 활성화 된 후에이 초기화를 수행해야합니다.
이렇게하면 해당 ECC 비트가 자동으로 업데이트됩니다. 이 초기화는 벡터 인터럽트가 사용될 때만 필요하며, 인덱스 인터럽트 관리에서는 테이블을 초기화 할 필요가 없습니다.

19.5.4 Interrupt Vector Table ECC Testing

ECC 검사 메커니즘을 테스트하기 위해 ECC 비트를 사용하여 수동으로 결함을 삽입 할 수 있습니다.
이 옵션은 ECCCTL 레지스터 제어 비트의 TEST_DIAG_EN 비트를 사용하여 구현됩니다.
TEST_DIAG_EN이 활성화되면 ECC 비트는 0xFFF82400에 매핑됩니다.
이 모드에서 사용자는 데이터 비트를 변경하지 않고 ECC 비트를 수정할 수 있습니다.
ECCENA가 비활성화 된 경우 데이터 비트에 기록해도 ECC 비트가 자동으로 업데이트되지 않습니다.
다른 조건에서의 CPU 읽기 및 쓰기는 표 19-3 및 표 19-4에 요약되어 있습니다.
그런 다음 사용자는 데이터 또는 ECC 비트에 오류를 강제 적용 할 수 있습니다.
마지막으로 VIM 또는 CPU에서 인터럽트 벡터 테이블 (ECC 비트가 아님)을 읽어 ECC 오류를 트리거 할 수 있습니다. 테스트 모드에서 ECC 비트 읽기에 대해서는 ECC 검사가 수행되지 않습니다.

ECC 비트에 오류를 주입하고 ECC 검사 기능을 테스트하려면 다음 시퀀스를 사용해야합니다.
1. ECCENA를 활성 상태로 유지하면서 VIM RAM의 데이터 위치를 필요한 패턴으로 씁니다.
ECC 비트는 데이터 비트와 함께 자동으로 초기화됩니다.
2. ECCCTRL 레지스터의 TEST_DIAG_EN 필드를 사용하여 ECC 테스트 모드를 활성화합니다.
3.이 모드에서는 다음 방법 중 하나를 사용하여 ECC 비트를 손상시킬 수 있습니다.
? ECC 비트 읽기, 1 비트 뒤 쓰기 및 다시 쓰기
? ECC 비트 읽기, 2 비트 뒤 쓰기 및 다시 쓰기
4. 생성 된 종류에 따라 데이터 비트를 다시 읽고 정정 오류 (단일 비트 오류 또는 이중 비트 오류 또는 오류 없음)를 확인하십시오.
5. UERRADDR 및 SBERRADDR 레지스터를 읽고 올바른 주소 캡처를 확인하십시오

데이터 비트에 오류를 주입하고 ECC 검사 기능을 테스트하려면 다음 시퀀스를 사용해야합니다.
1. ECCENA를 활성 상태로 유지하면서 VIM RAM의 데이터 위치를 필요한 패턴으로 씁니다.
ECC 비트는 데이터 비트와 함께 자동으로 초기화됩니다.
2. ECCCTRL 레지스터에서 ECCENA = 0으로 설정하여 ECC를 비활성화하십시오. 이 모드에서 데이터 비트에 기록해도 ECC 비트가 자동으로 업데이트되지 않습니다.
3.이 모드에서는 다음 방법 중 하나를 사용하여 데이터 비트를 손상시킬 수 있습니다.
? 데이터 비트 읽기, 1 비트 뒤 쓰기 및 다시 쓰기
? 데이터 비트 읽기, 2 비트 뒤 쓰기 및 다시 쓰기
4. 생성 된 종류에 따라 데이터 비트를 다시 읽고 정정 오류 (단일 비트 오류 또는 이중 비트 오류 또는 오류 없음)를 확인하십시오.
5. UERRADDR 및 SBERRADDR 레지스터를 읽고 올바른 주소 캡처를 확인하십시오.

NOTE :
ECC 검사 기능에 대한 테스트를 완료 한 후 유효한 데이터와 해당 검사 비트를 사용하여 VIM 인터럽트 벡터 테이블을 초기화해야합니다. UERR 및 SBERR 플래그 레지스터와 오류 주소 레지스터를 지우려면주의해야합니다.


19.6 VIM Wakeup Interrupt

웨이크 업 인터럽트는 저전력 모드 (LPM)를 벗어나는 데 사용됩니다.  //LPM : Low
모든 인터럽트 요청을 사용하여 장치를 깨울 수 있습니다. 리셋 후에 모든 인터럽트 요청은 LPM에서 웨이크 업하도록 설정됩니다.
그러나 VIM은 WAKEENASET 및 WAKEENACLR 레지스터를 사용하여 웨이크 업을 위해 원치 않는 인터럽트 회선을 마스크 할 수 있습니다.
REQENASET / REQENACLR의 값은 웨이크 업 인터럽트에 영향을 미치지 않습니다.

그림 19-10에서 볼 수 있듯이 WAKEENASET 및 WAKEENACLR 레지스터는 저전력 모드에서 깨우기 위해 인터럽트를 활성화 / 비활성화합니다.
모든 웨이크 업 인터럽트는 글로벌 클럭 모듈에 연결된 단일 신호 WAKE_INT에 "ORed"됩니다.


19.7 Capture Event Sources

VIM은 128 개의 인터럽트 요청 중 하나를 선택하여 실시간 인터럽트 (RTI) 모듈에 대해 최대 두 개의 캡처 이벤트를 생성 할 수 있습니다 (그림 19-11 참조).
REQENASET / REQENACLR의 값은 캡처 이벤트에 영향을주지 않습니다.
두 개의 레지스터 (19.9.17 절)가 각 캡처 이벤트 소스에 대해 하나씩 사용 가능합니다.



19.8 Examples

다음 절에서는 VIM의 작동에 대한 예제를 제공합니다.

19.8.1 Examples - Configure CPU To Receive Interrupts  (CPU가 인터럽트를 수신하도록 구성)

예 19-1은 CP15 R1 레지스터의 벡터 활성화 (VE) 비트를 설정하여 하드웨어 벡터 인터럽트를 활성화하는 방법을 보여줍니다.
예 19-2는 CPQR을 통해 IRQ 및 FIQ를 활성화 / 비활성화하는 방법을 보여줍니다.
협약으로,이 서브 루틴을 호출하는 프로그램은 필요할 경우 레지스터 R1을 보존해야합니다. 예 19-2는 권한 모드에서만 실행될 수 있습니다. 그러나 사용자 모드에서 응용 프로그램 소프트웨어는 명령 'SWI'에 의해 소프트웨어 인터럽트로 프로그램을 강제 실행할 수 있습니다.
그런 다음 소프트웨어 인터럽트 서비스 루틴에서이 예외 모드에서 CPSR의 복사본 인 레지스터 SPSR을 쓸 수 있습니다.

Example 19-1. Enable Hardware Vector Interrupt (IRQ Only)   (하드웨어 벡터 인터럽트 사용 (IRQ 만))
 
Example 19-2. Enable/Disable IRQ/FIQ through CPSR                (CPSR을 통한 IRQ / FIQ 활성화 / 비활성화)

Example 19-3. Exception Vector Configuration for VIM Vector    (VIM 벡터의 예외 벡터 구성)

NOTE :
프로그램 카운터 (PC)는 항상 현재 실행 된 명령을 넘어 두 개의 명령을 지시합니다. 이 경우 PC는 '0x18 또는 0x1C + 0x08'과 같습니다.
LDR 명령어는 'PC-0x1B0'에서 '0x18 또는 0x1C + 0x08 - 0x1B0 = 0xFFFFFE70 또는 0xFFFFFE74'인 메모리를로드합니다.
보류중인 ISR 주소를 저장하는 IRQVECREG 및 FIQVECREG의 주소입니다.

예 19-4는 인덱스 인터럽트에서 FIQ 인터럽트에 대한 빠른 응답을 보여 주며 둘 이상의 채널이 FIQ로 할당 된 시스템에 적용 할 수 있습니다.
TMS470R1x 레거시 코드와 호환되는 인덱스 인터럽트에 내장되어 있습니다.

Example 19-4. How to Respond to FIQ With Short Latency  (짧은 대기 시간으로 FIQ에 응답하는 방법)

FIQ 대기 시간을 향상시키는 또 다른 방법은 하나의 채널 만 FIQ 인터럽트에 할당하고이 채널에 해당하는 ISR 코드를 0x1C에서 직접 매핑하는 것입니다

NOTE : 
CPU가 벡터 가능 모드에있을 때, 예제 19-3과 예제 19-4는 여전히 유효합니다.
차이점은 CPU가 IRQ 인터럽트 동안 0x18 위치에서 읽지 않지만 해당 ISR 루틴으로 직접 점프합니다.

19.9 VIM Control Registers   (VIM 제어 레지스터)

표 19-5는 VIM 모듈 레지스터를 나열합니다.
각 레지스터는 워드 경계에서 시작됩니다.
모든 레지스터는 읽기 및 쓰기가 가능하도록 32 비트, 16 비트 및 8 비트 액세스가 가능합니다.
쓰기는 권한 모드에서만 가능합니다.
VIM 모듈의 기본 주소는 FFFF FE00h입니다. ECC 관련 VIM 레지스터의 기본 주소는 FFFF FD00h입니다.
목록에없는 주소 위치는 예약되어 있습니다.