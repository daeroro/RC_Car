24장. High-End Timer Transfer Unit(HTU) Module

(p.1064)
이 장에서는 하이 엔드 타이머 전송 장치 (HTU) 모듈에 대해 설명합니다.
HTU는 DMA (직접 메모리 액세스) 모듈과 비슷하지만 NHET (하이 엔드 타이머) 데이터를 마이크로 컨트롤러 RAM으로 전송하거나 마이크로 컨트롤러 RAM에서 전송하는 데 특화되어 있습니다.

NOTE : 
이 장에서는 DMA가 필요한 기능을 포함하는 HTU 모듈의 수퍼 셋 구현에 대해 설명합니다.
모든 장치에 DMA 기능이있는 것은 아니므로 장치 별 데이터 시트를 참조하여 사용중인 장치에 이러한 기능 및 기능의 적용 가능성을 확인하십시오.

(p.1065)
24.1 Overview (개요)
HET 전송 유닛은 메인 메모리 어드레스 범위에 위치한 NHET RAM 버퍼와 RAM 버퍼 사이에서 데이터를 전송하는 전용 직접 메모리 액세스 제어기이다.
따라서 측정 데이터를 수집하거나 출력 파형을 생성하여 CPU를 자유롭게하여 다른 작업을 수행 할 수 있도록 NHET RAM에 CPU 액세스 시간을 낭비하지 않아도됩니다.

24.1.1 Features (풍모)(?)

?NHET와 주 메모리간에 데이터를 독립적으로 전송합니다.
?듀얼 버퍼 구성을 지원하는 8 개의 이중 제어 패킷.
?NHET 지침 / 이벤트에 의해 생성 된 요청을 전송합니다.
?유연한 버퍼 처리를 위해 각 이중 제어 패킷에 대한 원 샷, 원형 및 자동 전환 버퍼 전송 모드.
?일정 및 후행 증가 어드레싱 모드.
?프로그래머블 메모리 보호 영역.
?패리티는 제어 패킷 RAM을 보호합니다.
?광범위한 진단 기능.


(p.1066)
24.2 Module Operation (모듈 작동)

HTU는 NHET에 단단히 연결되어 있으며 다른 주변 장치 모듈에서 데이터를 전송하지 않습니다.
그것은 NHET 프로그램과 구성 가능한 제어 패킷에 의해 생성 된 요청의 도움으로 전송을 시작합니다.
그림 24-1은 HTU의 시스템 블록 다이어그램과 데이터 전송을위한 기본 경로를 보여줍니다.
단단히 결합하고 전용 버스를 SCR (Switched Central Resource)에 연결하면 주변 장치 버스에서 전송되는 데이터의 양이 줄어들어 시스템 성능이 향상됩니다.
그러나 응용 프로그램이 NHET RAM에 직접 CPU 액세스 방법을 사용하기로 결정한 경우에는 그렇게 할 수 있습니다.
그림 24-2는 HTU 모듈의보다 상세한 블록 다이어그램을 보여줍니다.


                                                      Figure 24-1. System Block Diagram (그림)

(p.1067)


                                                   Figer 24-2. HTU Block Diargram

NHET RAM과 주 메모리 사이의 전송은 8 가지 다른 일반적인 NHET 요청에 의해 트리거됩니다.
정숙 한 요청은 특정 경우에 사용되며 24.2.4.1 절에서 논의됩니다.
출발지와 목적지 주소, 전송 횟수 및 기타 정보 (24.5 절 참조)를 저장하는 제어 패킷이 요청과 관련됩니다.
FIFO는 읽기 및 쓰기 경로를 분리하고 다른 읽기 및 쓰기 데이터 크기 인 경우 데이터 패킹을 수행 할 수 있습니다.
응용 프로그램은 데이터가 전송되거나 전송되는 메모리 섹션을 지정할 수 있습니다.
이것은 제어 패킷 RAM의 정보가 의도하지 않게 변경되어 HTU가 중요한 응용 프로그램 데이터를 덮어 쓸 수없는 경우 메모리 보호 역할을합니다.

제어 패킷은 데이터 전송을위한 두 개의 버퍼를 지정할 수있는 이중 제어 패킷 (DCP)으로 구현됩니다.
이렇게하면 CPU가 하나의 버퍼로 작업 할 수 있고 새 데이터는 다른 버퍼로 /에서 전송됩니다.

제어 패킷은 다음을 정의합니다 : 
?소스 / 목적지 버퍼의 시작 주소
? NHET 명령 주소 위치
? 전송해야하는 요소의 수
? 버퍼 처리

특정 조건 (예 : 캡처, 조건 비교)이 NHET 명령에 의해 감지되면 전송이 트리거됩니다.
NHET 명령은 이벤트에서 HTU에 대한 요청 라인이 트리거되도록 지정합니다.
DCP는 요청 회선에 고정 할당되어 있으며 해당 할당은 장치 데이터 시트에서 찾을 수 있습니다.
요청이 트리거되면 프레임 전송이 시작됩니다.
요청이 트리거되면 프레임 전송이 시작됩니다. 
프레임은 하나 이상의 요소를 포함 할 수 있습니다. 
요소는 32 비트 또는 64 비트 데이터 단어로 정의됩니다.

                                                 Figure 24-3. Example of a HTU Transfer


(p.1068)

24.2.1 Data Transfers between Main RAM and NHET RAM ( 메인 RAM과 NHET RAM 간의 데이터 전송)

24.2.1.1 Addressing Modes (주소 지정 모드)
제어 패킷의 어드레싱 모드는 CPU의 메인 RAM과 NHET RAM 사이에서 구별 될 필요가있다.

Main RAM

각 이중 제어 패킷 (24.2.1.3 절 참조)에 대해 주 RAM (RAM0 / 1)의 어드레싱 모드는 레지스터 IHADDRCT에서 상수 또는 사후 증가 모드로 구성 될 수 있습니다.
? Constant Addressing (고정 주소 지정) : 일정 모드에서 HTU는 주 RAM의 동일한 주소로 /에서 데이터를 쓰거나 읽습니다.
? Post-increment Addressing (사후 증가 주소 지정): 사후 증가 모드에서 HTU는 각 전송 후에 주소를 통해 증가시켜 주 RAM에 /에서 데이터를 쓰거나 읽습니다.
32 비트 전송을 선택하면 4 바이트 씩 자동으로 증가하고, 64 비트 전송을 선택하면 8 바이트 씩 증가합니다.
사용 사례의 예는 연속 증가 프레임의 요소가 주 RAM 버퍼의 연속적인 위치로 /에서 전송되는 사후 증가 모드를 보여줍니다.

NHET RAM

DCP가 NHET RAM을 처리하는 방법은 초기 NHET 주소, 초기 요소 카운터 (IETCOUNT) 및 NHET 주소 지정 모드 (ADDMH)에 의해 결정됩니다.
메인 RAM 어드레싱 모드의 가장 큰 차이점은 HET 주소가 프레임의 첫 번째 요소마다 초기 HET 주소로 재설정된다는 것입니다.
상수 주소 지정을 구현하려면 초기 요소 카운터를 1로 설정해야합니다. 후행 증가 주소 지정은 초기 요소 카운터를 1 이외의 값으로 프로그래밍하여 선택합니다.

23.2.1.2 Single Buffer Implementation (단일 버퍼 구현)

단일 버퍼 구현에서, DCP는 메인 RAM의 단일 버퍼로 /로부터 데이터를 전송하도록 설정된다.
각 전송 요청으로 프로그래밍 된 요소 수를 전송하고 프로그래밍 된 수의 프레임 전송이 완료되면 버퍼 포인터가 시작 주소로 재설정됩니다.
그림 24-4는 요소 카운터에 의해 시각화 된 할당 된 제어 패킷에서 실행되는 HTU 및 요청 프레임의 한 요청에 대한 요청을 보여줍니다.
다이어그램에서 프레임은 5 개의 요소 전송을가집니다 (요소 수 = 5).

(p.1069)

                                                                Figure 24-4. Single Buffer Timing and Memory Representation

응용 프로그램이 버퍼를 읽기 전에 응용 프로그램이 액세스하는 동안 새 데이터가 버퍼를 덮어 쓰지 않도록 제어 패킷을 비활성화해야합니다. t1 또는 t2에서 비활성화되는 제어 패킷에 관계없이 트리거 요청이 이미 수신 되었기 때문에 마지막 프레임이 항상 완료됩니다.
응용 프로그램은 TIPF 플래그 및 NACP 비트를 통해 진행중인 전송을 결정할 수 있습니다.
? One Shot Buffer Mode : TMBA 또는 TMBB가 원샷 버퍼 모드로 설정된 경우 버퍼 A 또는 버퍼 B의 모든 요소가 전송 된 후 데이터 스트림이 중지됩니다. 즉, 마지막 프레임이 버퍼 A 또는 B로 /에서 전송되고 CFTCTA 또는 CFTCTB가 0으로 감소한 후 해당 DCP가 비활성화됩니다.
? 원형 버퍼 모드 : TMBA 또는 TMBB가 원형 버퍼 모드로 설정된 경우 버퍼 A 또는 B의 모든 요소가 전송 된 후 버퍼 A 또는 B의 시작에서 데이터 스트림이 다시 계속됩니다.
순환 버퍼 모드의 타이밍 예제의 예는 IETCOUNT = 3 (초기 요소 전송 횟수), IFTCOUNT = 3 (초기 프레임 전송 횟수, SIZE = 0 (전송 크기 = 32 비트) 및 ADDFM = 0 (어드레싱 모드 주 메모리 = 사후 증가).
따라서 버퍼에는 총 9 개의 32 비트 값이 있습니다.
또한 IFADDRx = 10h라고 가정합니다.
"U"는 초기화되지 않았 음을 의미합니다.


(p.1070)

                                                               Figure 24-5. Timing Example for Circular Buffer Mode

24.2.1.3 Dual Buffer Implementation(이중 버퍼 구현)
전송 단위는 (HTU 요청 소스 당) 데이터 스트림 당 두 개의 버퍼 사용을 지원하는 이중 제어 패킷 (DCP)을 제공합니다.
하나의 버퍼가 CPU 또는 DMA에 의해 읽혀 져야하는 경우, 데이터 스트림은 다른 버퍼로 보내지고 첫 번째 버퍼는 고정됩니다.
다른 버퍼로 스위칭하는 CPENA에 쓰기 액세스 DCP 자동 다른 버퍼로 스위칭하도록 구성된 등록 또는 프레임의 프로그램 번호로 전송 된 트리거 될 수있다.(해석이 조금 이상함)
버퍼를 고정하면 CPU 또는 DMA가이 버퍼를 읽는 동안이 버퍼가 새 HET 데이터로 덮어 쓰지 않습니다.

그림 24-6은 두 개의 HET 명령어 1과 2의 타이밍 예제를 보여줍니다.
HTU (및 DCP 1 및 DCP 2에 의해 제어 됨). 생성 된 각 프레임에는 5 개의 요소 전송이 있습니다.
요구 소스 1은 2 개의 제어 패킷 1A 및 1B에 의해 제어되는 2 개의 RAM 버퍼를 갖는다.
요구 소스 2는 2 개의 제어 패킷 2A 및 2B에 의해 제어되는 2 개의 RAM 버퍼를 갖는다.

(p.1071)

                                                                   Figure 24-6. Dual Buffer Timing

그림 24-6은 버퍼 1A가 고정되고 데이터 스트림 1이 버퍼 1B로 보내지지만 프레임이 완료된 후에 만 시간 t1에서의 스위치를 보여줍니다.
또한 2A가 동결되고 데이터 스트림 2가 버퍼 2B로 보내지는 시간 (t2 또는 t3)을 보여줍니다.
요청과 프레임 시작 (예 : 시간 t3) 사이에 전환이 발생하면 프레임은 새 제어 패킷에 의해 처리됩니다 (이전 제어 패킷이 요청 시간에 활성화 되었음에도 불구하고).
HTU 요청과 요소 전송의 시작 사이의 지연은 HTU가 한 번에 하나의 전송 만 처리 할 수 있다는 사실에서 기인합니다.

Auto Switch Buffer Mode(자동 스위치 버퍼 모드)

TMBA가 자동 전환 모드로 설정된 경우 버퍼 A의 모든 요소가 전송 된 후 데이터 스트림이 버퍼 B의 시작에서 계속됩니다.
이것은 CPENA 레지스터에서 CP A가 비활성화되고 CP B가 자동으로 활성화되고 버퍼 B가 초기 주 메모리 주소 및 초기 프레임 카운터를 사용하여 시작한다는 것을 의미합니다.
동일한 원칙이 TMBB 및 버퍼 B에도 유효합니다.


(p.1072)
그림 24-7의 예는 IETCOUNT = 3 (초기 요소 전송 수), IFTCOUNT = 3 (초기 프레임 전송 수, SIZE = 0 (전송 크기 = 32 비트) 및 ADDFM = 0 (주소 지정 모드 주 메모리 = Post 증가).
따라서 버퍼 A와 B에는 총 9 개의 32 비트 값이 있습니다. 또한 IFADDRB = 10h 및 IFADDRA = 40h라고 가정합니다.
"U"는 초기화되지 않았 음을 의미합니다.

                                                                Figeure 24-7. Timming Example for Auto Switch Buffer Mode


24.2.1.4 General Control Packet Behavior(일반 제어 페킷 동작)
선택한 모드로 정의 된 동작은 프레임 카운터 값이 1 인 마지막 프레임의 끝에서 수행됩니다.
원샷 및 자동 전환 모드는이 때 CPENA 레지스터를 자동으로 업데이트합니다.
위에 나열된 세 가지 모드 모두에 대해 현재 버퍼의 끝에 도달하기 전에 CPENA에 기록하여 다른 버퍼로 전환 할 수 있습니다.
DCP x의 마지막 프레임 (프레임 카운터 = 1 포함)이 전송되는 동안 CPENA에 대한 쓰기 액세스가 발생하면 우선 순위는 표 24-1에 의해 정의됩니다.

                                                                         Table 24-1. CPENA / TMBx Priority Rules


(p.1073)

CPU가 주 메모리 조작을 원하지만 HTU가 주 메모리를 수정하는 것을 원하지 않는 경우가있을 수 있습니다.
요청이 이미 활성화되었지만 응용 프로그램이 제어 패킷을 비활성화했을 때 프레임 전송이 아직 시작되지 않았을 수 있습니다.
그림 24-8의 타이밍 다이어그램은이 시나리오를 보여줍니다.

                                                                       Figure 24-8. Timing for Disabling Control Packets

DCPx가 비활성화되기 전에 전송 요청이 이미 수신되었으므로 HTU는 여전히 프레임 전송을 시작합니다.
응용 프로그램은 DCPx가 비활성화 된 시점과 프레임이 시작되기 전에 BUSYx 비트를 감시하여 사용하지 않는 정보를 읽습니다.
그런 다음 모든 전송이 완료되었다고 생각하는 주 메모리 작업을 시작하지만 시간이 지나면 HTU가 뛰어난 프레임 전송을 시작하고 주 메모리를 손상시킵니다.

이를 피하기 위해 응용 프로그램은 HTU와 주 메모리 간의 모든 트랜잭션을 비활성화하도록 VBUSHOLD 비트를 설정할 수 있습니다.
버스에서 미해결 트랜잭션이 보류 중인지 확인하기 위해 BUSBUSY 비트를 감시해야합니다.
HTU는 여전히 NHET에서 모든 전송 요청을 수신하지만 VBUSHOLD 비트가 설정되어있는 동안 주 메모리로 데이터를 전송하거나 주 메모리에서 데이터를 전송할 수 없습니다.

이를 피하기 위해 응용 프로그램은 HTU와 주 메모리 간의 모든 트랜잭션을 비활성화하도록 VBUSHOLD 비트를 설정할 수 있습니다.
버스에서 미해결 트랜잭션이 보류 중인지 확인하기 위해 BUSBUSY 비트를 폴링해야합니다.
HTU는 여전히 NHET에서 모든 전송 요청을 수신하지만 VBUSHOLD 비트가 설정되어있는 동안 주 메모리로 데이터를 전송하거나 주 메모리에서 데이터를 전송할 수 없습니다.


24.2.2 Arbitration of HTU Elements and Frames(HTU 요소와 프레임의 중재)
?프레임은 서로 간섭하지 않습니다. 다른 프레임이 DCP y (및 x ≠ y)에서 실행되는 동안 DCP x에서 요청이 발생하면 현재 프레임이 새 프레임이 시작되기 전에 완료됩니다.
?둘 이상의 요청 행이 활성화 된 경우, 더 낮은 번호의 요청 행 (해당 NHET 명령의 요청 번호 필드에 지정됨)이 먼저 처리됩니다.


24.2.3 Conditions for Frame Transfer Interruption (프레임 전송 중단 조건)
프레임이 현재 DCP x에서 전송되고 아래에 나열된 이벤트 중 하나가 발생하면 이벤트가 DCP x의 요소 카운터를 지우고 (2) DCP x (3)에서 새 요소 전송을 중지합니다. DCP x의 활성 중 비트 및 (4) CPENA 레지스터에서 DCP x를 디스 에이블한다. DCP x 이외의 DCP는 영향을받지 않습니다.
? DCP x의 분실 요청 요청 (CORL 비트가 0으로 설정 됨).
? DCP x의 패리티 오류 (패리티 검사가 활성화되고 COPE 비트가 0으로 설정 됨). 24.2.6 절을 참조하십시오.
? DCP x의 버스 오류.
? DCP x의 메모리 보호 오류 (메모리 보호가 활성화 된 상태). 24.2.5 절을 참조하십시오.
? 해당 비트가 1이면 BUSY 비트 (DCP x에 속함)에 1을 씁니다. BUSY 비트가 0이면 효과가 없습니다.
? 하나를 HTURES 비트에 씁니다.
메모리 보호 오류가 발생하면 보호 된 주소에 대한 액세스가 차단됩니다.
위반 전송을 야기한 요소가 시작되기 전에 프레임이 중지됩니다.
다른 모든 오류는 현재 요소 전송이 완료되도록합니다.

Request Lost 및 Bus Error의 경우, 프레임이 실제로 중지되기 전에 하나 이상의 요소 전송이 버스에서 진행됩니다.
따라서 사용중인 비트는 오류를 유발 한 요소 다음에 오는 요소 다음에 지워집니다.

버스 오류의 경우 오류의 원인이 된 요소 뒤에 오는 요소의 카운터가 ERRETC 레지스터 필드에 캡처됩니다.



(p.1073)

NOTE : 프레임이 전송되는 동안 HTUEN 비트가 지워지면 HTU가 비활성화되기 전에 프레임이 완료됩니다.

24.2.4 HTU Overload and Request Lost Detection(HTU과부하 및 요청 손실 방지)

서로 다른 HTU 요청 소스의 수가 "높다"면, 요청 간의 간격은 "짧다"그리고 / 또는 초기 요소 카운터 값은 "큰"경우 HTU는 과부하 상황에 빠질 수있다.
그림 24-9에서 "L"로 표시된 모든 요청은 다음 요청이 발생할 때 프레임이 완료되지 않았기 때문에 손실됩니다.
"TU request (x)"행의 각 숫자는 관련 NHET 명령이 DCP x에서 요청을 생성하는 시간을 나타냅니다.
그림 24-9의 화살표는 관련 프레임을 가리키며 요청과 비교하여 지연 될 수 있습니다.
지연은 현재 처리중인 다른 프레임에 의해 발생합니다.
그림에서는 RLBECTRL 레지스터의 CORL 비트가 설정되어 DCP가 활성화 된 상태로 유지되고 DCP에서 요청 손실 오류가 발생한 후에도 데이터 스트림이 계속되도록합니다 (TU 요청 (2)의 경우 3-L 참조).

                                                Figure 24-9. Timing Example Including Lost Requests

잃어버린 요청은 RLOSTFL 레지스터와 함께 시그널링되며, 가능하다면 요청이 손실 된 인터럽트를 생성 할 수 있습니다.

CORL 비트가 설정되면 프레임이 완료되고이 프레임에서 요청이 손실 된 경우에도 해당 DCP가 계속 사용됩니다.

이중 버퍼 모드에서 요청 손실 감지는 CP 스위치와 독립적으로 계속 작동합니다.

24.2.4.1 Requests and Quiet Requests (요청 및 조용한 요청)
너무 많은 전송 요청을 생성하여 HTU에 과부하가 걸리고 데이터를 전혀 전송할 수 없으면 불일치 데이터가 전송 될 수 있습니다.
다음 예제는 그러한 시나리오를 설명합니다.

아래의 예에서, HTU는 세 가지 다른 지시의 데이터 필드에서 세 요소의 프레임을 읽습니다.
그림 24-10에서 L3 명령어는 시간 t2, t7 등에서 HTU 요청을 생성합니다.
및 해당 프레임 (t3에서).
HTU로드로 인해 프레임이 지연됩니다.
그러나 그림 24-10에 표시된 것처럼 지연은 명령 L1의 데이터 필드가 다시 업데이트되기 전에 프레임이 완료되도록합니다.
그러나 지연이 더 길면 (그림 24-11 에서처럼) 프레임이 NHET 루프 (LRP)로 떨어질 수 있으며,이 경우 NHET은 L1, L2 및 L3 명령어의 데이터 필드를 업데이트합니다.
이 경우 HTU는 그림과 같이 일치하지 않는 데이터를 읽을 수 있습니다.
L1에서 (시간 t3에서) 잘못된 (새로운) 값이 판독되지만, L2 및 L3 (시간 t4 및 t5에서)에서 정확한 ( "구형") 값이 판독됩니다.


(p.1074)

                                            Figure 24-10. Timing which Generates No Request Lost Error

                                           Figure 24-11. Timing which Generates a Request Lost Error

일관성있는 데이터를 보장하기 위해 NHET 지침은 전송을 시작하지는 않지만 일관성 검사를 위해 HTU에서만 사용하는 조용한 요청을 생성 할 수 있습니다.
조용한 요청이 발생할 때 프레임이 마지막 요청 이후 완료되지 않았거나 시작되지 않은 경우 HTU는 요청 손실 오류를 신호합니다.
요청을 생성 할 수있는 모든 지침은 대신 조용한 요청을 생성하도록 구성 할 수 있습니다.
따라서 그림 24-10과 그림 24-11의 예에서 명령 L1은 조용한 요청을 생성하고 명령 L3은 정상 요청을 생성하도록 구성되어야합니다. 그림 24-11의 경우 RLOSTFL 레지스터의 해당 비트가 설정됩니다.

DCP x로 처리되는 명령 블록의 첫 번째 명령에 대한 조용한 요청을 가능하게하고이 블록의 마지막 명령에 대해서만 정상 요청을 가능하게하는 것은 NHET 소프트웨어의 책임입니다. 조용한 요청을 활성화하면 DCP x에 대한 적절한 요청 손실 감지가 가능하므로 NHTP 지침 모두 동일한 DCP x (reqnum = x)를 지정해야합니다.

HET 명령어의 제어 필드는 2 비트 필드를 제공하여 다음과 같은 가능성 중 하나를 구성합니다 (표 24-2 참조).
프로그램 필드의 3 비트 필드는 요청에 의해 트리거 될 8 개의 이중 제어 패킷을 선택합니다.

                                                Table 24-2. Triggered Control Packets

(p.1076)
매우 가벼운 HTU 부하이지만 높은 신호 요구 사항 (예 : 고주파수)의 경우에는 조용한 요청을 사용하여 제어 패킷에 의해 읽혀지는 데이터가 안전 한 기간을 정의 할 수 있습니다.
다음 HET 코드는 상승 에지 (핀 CC6에서)와 하강 에지 이후 (핀 CC6에서) L2-WCAP 데이터 필드에 대한 카운터 타임 스탬프를 L1-WCAP 데이터 필드에 캡처합니다.


                                                    Figure 24-12. Timing Example for Two WCAP Instructions

HTU 프레임에는 두 가지 요소가 있습니다. 첫 번째는 상승 에지 r (n)의 타임 스탬프를 제공하고 두 번째는 이전 하강 에지 f (n-1)의 타임 스탬프를 제공합니다. 위의 코드를 사용하면 그림 24-12에 표시된 시간에 요청 (R)과 조용한 요청 (QR)이 발생하고 손실 된 요청은 RL로 표시된 시간 동안 프레임이 액세스 할 때만 신호를받습니다.
따라서 프레임 요소로 [22, 21]을 읽는 것은 정확합니다.
신호 주파수가 증가하면 잘못된 쌍 [22,24]을 읽을 수 있지만 적어도 e2가 RL 기간에 속하기 때문에 요청 손실 오류로 신호를 보냅니다.

24.2.5 Memory Protection (메모리 보호)
이 기능을 사용하면 중요한 응용 프로그램 데이터가 의도하지 않게 HTU에서 조작되는 것을 방지하기 위해 메모리의 특정 영역에 대한 액세스를 제한 할 수 있습니다.

HTU 메모리 보호 기능이 비활성화 된 경우 예외없이 HTU가 4GB의 전체 주소 범위에 액세스 할 수 있습니다.
시작 및 끝 주소를 구성 할 수있는 두 개의 메모리 영역이 있습니다.
메모리 보호 기능을 사용하면 정의 된 영역 내의 HTU에 의한 읽기 및 쓰기 액세스가 허용됩니다.
지역 외부의 액세스에는 두 가지 모드 중 하나를 구성 할 수 있습니다.
? HTU에 의해 수행 된 모든 액세스는 금지되어 있으며 ESM 모듈에 신호를 보냅니다. 쓰기 액세스가 차단됩니다.
? 읽기 액세스는 허용되지만 쓰기 액세스는 차단되고 ESM 모듈에 신호가 전달됩니다.
한 영역 만 사용하려면 REG01ENA가 0이어야합니다. 비트 ACCR01, INTENA01 및 레지스터 설정
MP1S 및 MP1E는 무시됩니다.

두 지역을 모두 사용하는 경우 아래 규칙을 준수해야합니다.
1. 메모리 맵핑 된 영역 0은 메모리 맵핑 된 영역 1과 같이 하위 메모리 영역을 포함합니다.
2. REG01ENA는 하나이며 REG0ENA는 0입니다.
3. ACCR01이 원하는 액세스 유형으로 설정되면 ACCR0은 무시됩니다.
4. INTENA01이 원하는 동작으로 설정되면 INTENA0은 무시됩니다.

DCP x의 요소 전송에서 메모리 보호 오류가 발생하면 다음을 수행합니다.
1.  DCP x의 요소 카운터가 지워집니다.
2. DCP x의 모든 새 요소 전송이 중지됩니다.
3. DCP x의 활성 중 비트가 해제됩니다.
4. DCP x는 CPENA 레지스터에서 비활성화됩니다. DCP x 이외의 DCP는 영향을받지 않습니다.
5. FT 플래그가 설정됩니다.
6. 오류가 ESM 모듈에 전달됩니다.

24.2.6 Control Packet RAM Parity Checking (제어 페킷 RAM 검사 패킷.)

HTU 모듈은 DCP (Double Control Packet) RAM의 패리티 오류를 감지 할 수 있습니다.
DCP RAM 패리티 검사는 바이트 당 하나의 패리티 비트를 사용하여 구현됩니다.
짝수 또는 홀수 패리티 검사는 시스템 모듈의 DEVCR1 레지스터에서 선택할 수 있으며 PCR 레지스터의 4 비트 키로 활성화 / 비활성화 할 수 있습니다.

DCP RAM에 대한 읽기 액세스 중에 RAM에서 읽은 데이터를 기반으로 패리티가 계산되고 패리티 비트에 저장된 양호한 패리티 값과 비교됩니다.
패리티 검사는 HTU 또는 다른 마스터 (예 : CPU)가 DCP RAM에 대한 읽기 액세스를 할 때 수행됩니다.
초기 또는 현재 DCP의 RAM 섹션 내의 읽기 액세스는 한 번에 DCP의 모든 16 바이트를 검사합니다 (DCP 메모리 맵 참조).
예를 들어 바이트 읽기 액세스가 DCP RAM 주소 0에 대해 발생하지만 바이트 주소 Ch에 패리티 오류가있는 경우 패리티 오류가 발생하고 캡처 된 패리티 주소는 0이 아닌 Ch가됩니다.
오류가 발생한 바이트의 주소는 PAR 레지스터에서 읽을 수 있습니다.
연속적인 DCP RAM 읽기 액세스가 다중 패리티 오류를 생성하면 첫 번째로 감지 된 오류의 주소 만 캡처되고 PAR 레지스터는 응용 프로그램에서 읽을 때까지 후속 오류로 업데이트되지 않습니다.
16 바이트 단어의 여러 오류가 감지되면 가장 낮은 바이트의 주소 만 캡처됩니다.

응용 프로그램은 패리티 오류가 감지 될 때 전송을 중지할지 또는 데이터 전송을 계속할지 여부를 결정할 수 있습니다.
COPE (패리티 오류 계속) 비트가 0이고 패리티 검사가 활성화 된 경우 HTU는 프레임을 시작하지 않고 해당 DCP는 CPENA 레지스터에서 자동으로 비활성화됩니다.
HTU가 아닌 마스터 (예 : CPU)가 DCP x의 RAM 섹션을 읽고 패리티 검사가 활성화되어 있고 COPE 비트가 0 인 동안이 읽기 액세스 중에 패리티 오류가 감지되면 DCP x는 CPENA 레지스터에서 자동으로 비활성화됩니다.
이 읽기 액세스 중에이 DCP x의 프레임이 진행 중이면 DCP x의 요소 카운터가 지워지고 DCP x의 모든 새 요소 전송이 중지되고 DCP x의 활성 중 비트가 지워집니다. COPE를 1로 설정하고 패리티 검사를 활성화하면 패리티 검사가 여전히 수행되지만이 DCP에 대해 패리티 오류가 감지 된 후 활성 DCP의 데이터 전송이 계속됩니다.
따라서 패리티 오류가있는 DCP는 비활성화되거나 프레임이 중지되지 않습니다.

DCP가 활성화 된 후 (BIM = 0을 사용하는 CPENA 사용) 첫 번째 프레임이 시작될 때 HTU는 현재 DCP 정보가 필요 없으므로 초기 DCP에서만 패리티 검사를 수행합니다.
이후 프레임의 경우 HTU는 두 정보가 모두 필요하기 때문에 초기 DCP와 현재 DCP 모두에 대해 패리티 검사를 수행합니다.

패리티 오류 감지에서 오류는 ESM 모듈에도 전달됩니다.


(p.1078)
24.2.6.1 Parity Bit Mapping and Testing (패리티 비트 매핑 및 테스트)

패리티 검사 메커니즘을 테스트하기 위해 수동 오류 삽입을 허용하기 위해 패리티 RAM을 액세스 가능하게 만들 수 있습니다.
TEST 비트가 설정되면 패리티 비트는 FF4E 0200h 번지에 매핑됩니다.

테스트 모드에있을 때 (패리티 RAM에 액세스 할 수 있음) 읽기에서 패리티 검사가 수행되지 않습니다
패리티 RAM에 저장되지만 패리티 검사는 여전히 DCP RAM에 대한 읽기 액세스에 대해 수행됩니다.

표 24-3 및 표 24-4는 DCP RAM 바이트의 해당 패리티 비트가 메모리에 매핑되는 방법을 보여줍니다.

                                                                                                  Table 24-3. DCP RAM

                                                                                              Table 24-4. DCP Parity RAM

DCP RAM의 각 바이트는 DCP 패리티 RAM에 자체 패리티 비트가 있습니다. P0는 바이트 0에 대한 패리티 비트이고, P1은 바이트 1에 대한 패리티 비트이며, 계속 계속됩니다.

24.2.6.2 Initializing Parity Bits (패리티 비트 초기화)
장치의 전원이 켜지면 패리티 비트를 포함한 DCP RAM 내용을 보장 할 수 없습니다.
패리티 오류를 방지하려면 DCP RAM을 읽을 때 RAM을 먼저 초기화해야합니다.
이것은 알려진 값을 소프트웨어로 RAM에 쓰면 간단히 수행 할 수 있으며 해당 패리티 비트는 자동으로 계산됩니다.

DCP 메모리와 패리티 비트를 초기화하는 또 다른 방법은 시스템 모듈을 사용하는 것입니다.
HTU 외부의 온칩 모듈.
이 모듈은 HTU DCP RAM을 포함하여 마이크로 컨트롤러에있는 모든 RAM의 자동 초기화를 시작할 수 있습니다.
이 함수는 시스템 모듈에 의해 활성화 될 때 완전한 DCP RAM을 "0"으로 초기화합니다.
짝수 / 홀수 패리티 선택에 따라 모든 패리티 비트가 그에 따라 계산됩니다.
자동 DCP RAM 초기화 중에는 HTUEN 비트를 지워야하고 패리티 기능을 활성화해야합니다 (PARITY_ENA에 의해).
시스템 모듈에 의해 초기화가 트리거 될 때 HTUEN이 하나 인 경우, 초기화는 수행되지 않고 HTU 조작은 영향을받지 않습니다.
초기화 중에 HTUEN에 기록 된 것이면 HTUEN 비트가 설정되지만 초기화가 완료되기 전에 HTU는 활성화되지 않습니다.


(p.1079)

24.3 Use Cases (사용 사례)

24.3.1 Example: Single Element Transfer with One Trigger Request (하나의 트리거 요청으로 단일 요소 전송)
이 예에서는 HTU가 주 (CPU) 데이터 RAM의 RAM 버퍼를 채우는 경우를 고려합니다.
HTU는 HTU 요청을 생성하는 명령어를 읽습니다.

이 예제에서는 PCNT 명령어를 사용합니다.
PCNT가 새 펄스 또는 마침표 값을 캡처 할 때마다 HTU 로의 전송 요청을 자동으로 생성 한 다음 NHU RAM에서 버퍼 RAM으로 값을 전송합니다.
따라서 시간이 지남에 따라 RAM 버퍼의 연속 위치는 CPU로드 또는 인터럽트없이 동일한 PCNT 명령의 NHET RAM 데이터 필드에 캡처 된 연속 측정 값으로 채워질 수 있습니다.

24.3.2 Example: Multiple Element Transfer with One Trigger Request(하나의 트리거 요청으로 다중 요소 전송)
다음 예는 동일한 NHET 입력 신호 (한 핀)에 속하는 여러 유형의 측정 값을 포함하는 데이터 스트림으로 RAM 버퍼를 채우는 데 HTU를 사용할 수있는 방법을 보여줍니다: 타임 스탬프 값 (WCAP), 에지 카운터 값 (ECNT) 및 마지막주기 값 (PCNT).

그림 24-13은 타이밍을 보여 주며 표 24-5는 WCAP-ECNT-PCNT 명령 블록의 프로그램 (PF), 제어 (CF), 데이터 (DF) 및 예약 필드 (res)의 바이트 주소를 보여줍니다 .
타이밍 및 코드 예제에서는 세 가지 명령 모두가 동일한 NHET 핀에 할당되어 있다고 가정합니다.

                                               Figure 24-13. Timing of the WCAP, ECNT, PCNT Example

                                              Table 24-5. Field Addresses of the WCAP, ECNT, PCNT Example

HET 코드에서 HTU 요청은 WCAP-ECNT-PCNT 블록의 마지막 명령 (PCNT)에 대해서만 활성화됩니다. PCNT 조건이 참일 때, 생성 된 HTU 프레임은 WCAP, ECNT 및 PCNT의 데이터 필드에서 3 개의 HTU 요소 읽기를 수행합니다.

(p.1080)

데이터 필드의 32 비트 전송 :
표 24-6은 위에 설명 된 예제에서 내부 요소 카운터, 프레임 카운터 및 주소 레지스터가 시간에 따라 어떻게 변하는지를 보여줍니다.
PCNT 명령이 새 값을 캡처 할 때마다 HTU에 프레임을 시작하라는 요청을 생성합니다.
각 프레임의 끝에는 프레임 카운터가 감소합니다.

                                        Table 24-6. 32-Bit-Transfer of Data Fields

대상 버퍼는 표 24-7에 표시된대로 WCAP, ECNT 및 PCNT 데이터 필드 값으로 채워집니다.

                                         Table 24-7. Destination Buffer Valuese 


이 예의 HTU 제어 패킷의 해당 설정은 다음과 같습니다.(밑에 얕은 글시로 코딩이 있음)