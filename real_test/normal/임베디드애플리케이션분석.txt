1. 리눅스 및 유닉스에서 파일을 읽는 절차에 대해 기술하시오.

우선 읽고자 하는 파일에 대해 open() 을 수행한다.
이를 통해 파일 디스크립터를 얻고 read() 를 수행해서 char 배열에 내용을 가져오면 된다.
이 내용을 출력하면 파일에 기록되어 있는 내용을 읽을 수 있다.

2. 리눅스에서 특정 파일을 생성해서 내용을 적는 방법에 대해 기술하시오.

만들고자 하는 파일을 open() 하고 이를 통해 파일 디스크립터를 얻는다.
다음으로 write() 를 통해서 적고자 하는 내용을 char 배열에서 파일 디스크립터로 보낸다.
프로그램을 돌린 이후에 파일을 보면 내용이 잘 기록 된 것을 볼 수 있을 것이다.

3. 리눅스에서 lseek() 시스템 콜을 어떻게 활용할 수 있는지 기술하라.

파일 내에서 내용을 읽거나 쓰면 task_struct->files_struct->file->f_pos 의 파일 포인터가 이동한다.
이 위치를 우리가 원하는 위치로 이동시키는데 lseek() 를 사용 할 수 있다.
이를 통해서 특정 위치에 내용을 추가하거나 수정하는 작업을 수행 할 수 있다.

4. 리눅스에서 fork() 시스템 콜을 사용하는 경우 어떤 일이 발생하는지 기술하시오.

애플리케이션 레벨에서는 단순히 자식 프로세스가 생성 된다 볼 수 있다.
커널 레벨에서는 task_struct 라는 객체가 만들어진다.
또한 메모리가 복사가 되며 Demand On Paging 에 입각하여 동작하게 된다.

5. fork() 와 open() 을 사용한 프로그램이 존재하는 경우 파일 포인터가 공유 되는지 기술하시오.

파일 포인터는 공유되지 않는다.
별도의 file 구조체가 열리기 때문이다.
그래서 디스크립터 번호도 다르다. 

6. pthread_create() 는 스레드를 생성한다.
   스레드 또한 태스크와 동일하게 Linux Kernel 상에서 task_struct 로서 생성 된다.
   그렇다면 같은 그룹에 묶여있는 스레드들을 파악하는 방법은 무엇일까 ?

task_struct 구조체 내부에 tgid 가 같은 녀석들은 전부 같은 스레드 그룹에 묶여 있는 것이다.

7. MCU 에 Linux Kernel 을 올릴 수 없는 이유가 무엇인가 ?

MMU 가 없기 때문에 Paging 을 수행 할 수 없어 일반적인 범용 OS 는 MCU 에 올라갈 수 없다.

8. 프로그래밍 시에 execve() 를 사용한 이후 아래 부분의 코드가 증발하는 이유가 무엇인가 ?

execve() 는 메모리 레이아웃 자체를 변경하는 시스템 콜이기 때문에
이 시스템 콜을 사용한 이후에는 모든 메모리 아웃이 변경되어
더 이상 이전에 구동시켰던 프로그램의 레이아웃이 남아있지 않아 기존 부분이 증발하게 된다.

9. 그렇다면 execve() 를 사용한 이후 아래 부분의 코드 증발을 방지하기 위한 방법은 무엇인가 ?

fork() 시스템 콜을 사용하여 프로세스를 분리시켜버리는 것이다.
하나가 execve() 를 통해 다른 메모리가 되어주면
남은 하나는 본연의 임무를 수행 할 수 있게 된다.

10. stat() 시스템 콜의 용도는 무엇인가 ?

파일의 권한 및 종류를 파악하는데 사용한다.
이를 통해 이것이 디렉토리인지, 파일인지, 디바이스(장치) 관련 파일인지 알 수 있다.
