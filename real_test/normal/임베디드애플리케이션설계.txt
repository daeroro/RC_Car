1. signal() 시스템 콜의 프로토타입에 대해 기술해보자.

void (* signal(int signum, void (* handler)(int)))(int)

void (*)(int) 함수 포인터를 리턴하고
인자로 int 형 signum 과 void (*)(int) 함수 포인터 handler 를 인자로 취하는 함수 signal

2. signal() 시스템 콜의 반환 값은 무엇을 의미하는지 기술하시오.

앞서서 동작했던 signal 의 handler 의 포인터를 의미한다.
즉 맨 처음 signal() 동작에서 반환값은 0 이다.

3. sticky bit 가 디렉토리에 붙은 경우에 어떻게 동작하는지 기술하시오.

sticky bit 는 0 ~ 11 까지의 권한 비트 중 9 번 비트에 해당한다.
이 비트가 디렉토리에 붙었을 경우 공유 디렉토리가 된다.

4. OS 만지는 사람이 절대로 모르면 안되는 Paging 에 대해 기술해보시오.

우리가 다루는 시스템이 ARM 이므로 이에 맞춰 기술해보자면
32 비트 시스템에서 페이징은 10 비트, 10 비트, 12 비트로 가상 메모리 주소를 쪼갠다.
그리고 각각의 실제 물리 메모리인 페이지 프레임을 찾기 위한 인덱스로서 활용이 된다.
최종적으로 마지막 인덱스까지 찾아가면 페이지 프레임에 접근 할 수 있게 된다.
그렇기 때문에 우리가 보는 가상 메모리 주소는 실제 메모리의 주소가 아니란 것도 알 수 있다.

5. sticky bit 가 파일에 붙은 경우에 대해 기술해 보시오.

파일 자체를 swap 공간과 함께 활용하고자 할 경우에 사용한다.
페이징을 하게 된다는 것은 10 bit, 10 bit, 12 bit 연산을 수행하는 것이므로
이 작업을 여러 번 하게 되는 것이 꽤나 부하가 크다는 것이다.
그래서 이미 페이징 된 정보를 디스크에 저장해서 필요한 경우
즉각즉각 페이징 없이 가져올 수 있도록 도와주는 것이 swap 파일 시스템이다.
sticky bit 를 파일에 붙이면 이 swap 파일 시스템을 활용 할 수 있게 된다.

6. 리눅스 커널의 스케쥴러는 O(N) 과 O(1) 방식이 존재했다.
   그렇다면 O(N) 과 O(1) 중 누가 더 좋은 것일지 기술해보자.

데이터의 개수가 적다면 오히려 O(N) 이 더 좋을 수 있는데
데이터의 개수가 많다면 많던 적던 언제나 일정한 성능을 내주는 O(1) 이 더 좋다고 볼 수 있다.
대표적인 알고리즘이 Hash Table 에 해당한다.

7. Shared Memory 의 동작 메커니즘을 기술해보자.

Shared Memory 는 실제 페이징 된 물리 메모리를 공유하게 만들어주는 기법이다.
즉 애초에 같은 메모리를 공유 한다는 것이다.

8. readdir() 을 통해서 얻는 것은 무엇인가 ?

먼저 opendir() 을 통해 디렉토리를 열고 readdir() 을 통해서 디렉토리 엔트리를 얻는다.
그리고 여기서 얻은 정보를 기반으로 파일 이름과 종류 등을 추출 할 수 있다.

9. Critical Section 에 대해 기술하시오.

하나의 공유 자원에 동시다발적으로 여러 개의 스레드들이 접근해서 이 값을 바꿀 수 있는 경우라면
해당 공유 자원이 결국 Critical Section 이 되고 이 문제를 해결하기 위해 IPC 통신이 필요하다.

10. 네트워크 프로그래밍을 수행함에 있어서 중요한 시스템 콜들을 기술하시오.

socket(), bind(), accept(), connect(), listen() 에 해당한다.