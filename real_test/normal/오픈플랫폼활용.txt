1. 능력단위요소: 오픈 플랫폼 개발 환경 구축

   TI 사의 Cortex-R5F TMS570LC4357 HDK 를 개발하려고 한다.
   리눅스에 CCS 를 설치하고 HalCoGen 을 구성할 것이다.
   프로젝트를 생성해서 Target 보드에 Flash 하는 일련의 절차를 기술하라.

* CCS 를 키고 Target Architecture 를 맞춘다.
* 프로젝트 경로를 복사해서 HalCoGen 에서도 프로젝트를 맞춰준다.
* 이후에 사용하고자 하는 Peripheral 들을 설정하고 CCS 와 연동한다.
* CCS 상에서 Peripheral 을 제어하는 코드를 작성하고 Flash 한다.
* 보드를 구동시켜 동작을 확인한다.

2. FPGA 에서 PL 과 Linux 의 PS 를 모두 활용 할 수 있는 것을 Zynq 라고 한다.
   여기서 Petalinux 에 대한 것을 기술하시오.

Petalinux 는 Xilinx 사에서 만든 Linux 로 현재 Kernel 4.x 대 버전을 사용한다.
또한 커널 컴파일을 어느정도 자동화 시켜놨기 때문에
FPGA 상의 PL 을 Linux 상의 장치 파일로 만들어
Device Driver 와 이를 연동하는 유저 프로그램으로 제어를 수행 할 수 있다.

3. 유닉스 및 리눅스의 핵심 철학은 "모든 것은 파일이다" 인데 이를 자세히 기술하시오.

리눅스 커널의 task_struct 구조체에 들어가면
files_struct 구조체가 있고 여기서 file 구조체에 file_operations 라는 구조체가 있다.
이 구조체 안에는 파일 연산에 대한 함수 포인터들이 배치 되는데
디바이스 드라이버의 Wrapping 함수도 여기에 맵핑되어
실제 HW 장치와 관련된 제어도 여기서 이루어진다.
파일을 관리하는 구조체에서 작업이 이루어지기 때문이다.

4. C 언어에서 함수 포인터를 활용하는 이유는 무엇인가 ?

C++ 은 구조체 안에 함수를 집어넣어서 Abstraction 을 구사 할 수 있다.
C 언어로도 C++ 의 Class 를 유사하게 구현 할 수 있으니
함수의 주소를 저장하는 함수 포인터를 활용하면 C++ 처럼 C 언어를 구사 할 수 있다.
그 외에 같은 이름으로 서로 다른 동작도 수행시킬 수 있다.
이것의 대표격이 바로 가상 파일 시스템에 해당한다.

5. TI DSP 에서 하드웨어 가속을 수행하려고 한다.
   어떻게 해야 하는가 ?

PC 에서는 CPU 와 GPU 를 묶어서 가속하기 위해 GPGPU 라는 것을 수행한다.
혹은 CUDA 라는 것도 존재하며 OpenCL 이라는 것도 존재한다.
TI DSP 에서는 CPU 와 DSP 를 OpenCL 로 묶어서 하드웨어 가속을 수행 할 수 있다.

6. TMS570 Cortex-R5 보드에서 BLDC 모터를 제어하고자 한다.
   우선 ESC Calibration 을 완료해야 하는데 어떻게 해야 하는가 ?

일반적으로 ESC 의 설명서에 보면 Full 스로틀을 넣기 위해
전체 주기 20 ms 에서 PWM 최대 Duty 인 2 ms 를 넣고 1 초간 대기 후
최소 Duty 인 1 ms 를 3 초간 넣음으로써 ESC Calibration 을 완료 할 수 있다.

7. 우리가 사용하는 Xilinx 사의 칩을 쓰는 Zybo 보드에서 모터를 제어해보자
   이 경우 어떠한 절차를 수행해야 모터를 제어 할 수 있을까 ?

Zybo 보드에는 PWM 핀이 별도로 존재하지 않는다.
그렇다면 PL 레벨에서 Timer 를 만들어서 주기 20 ms 와 Duty 1 ~ 2 ms 를 만들면 된다.
혹은 Custom IP 를 만들어서 PWM 제어를 수행하도록 만들어도 된다.

8. 우리가 프로젝트에 사용할 TI DSP 에 코드를 올리는 경우를 생각해보자.
   이 보드에 코드를 올리기 위해서 Cross 플랫폼 설정을 해야 한다.
   교차 개발 환경이라고도 하는데 이에 대해 기술하라.

우리가 PC 에서 사용하는 gcc 컴파일러는 x86 아키텍처로 만들어져 있다.
x86 아키텍처로 만들어진 컴파일러가 x86 아키텍처 바이너리를 만든다.
반면 Target Board 에 올릴때는 x86 아키텍처가 ARM 바이너리를 만들어야 한다.
gcc 뿐만 아니라 어셈블러, 링커 등이 모두 ARM 전용 바이너리를 만드는데 집중해야 한다.
그래서 구성이 많이 달라지는데 이러한 환경을 크로스 개발 환경이라고 한다.

9. 회로를 구성하고 멀티미터를 통해서 전압 및 전류를 측정하고자 한다.
   어떻게 측정해야 하는지 기술하시오.

전압은 저항 양단에 찍거나 그라운드와 전압이 걸리는 구간을 찍으면 된다.
전류의 경우 멀티미터가 병렬 구성이 아닌 직렬 구성이 되게 연결해줘야 측정 가능하다.

10. x86 어셈블리어에서 call 명령에 대한 동작을 기술하시오.

Intel Architecture 에서는 call 명령어는 복귀 주소에 대한 주소값을
스택에 push 하고 실제 함수의 주소로 jmp 하게 된다.
여기서 사용하는 주소값은 실제로 전부 가상 메모리에 해당한다.

11. ARM 어셈블리어에서 함수를 호출하는 방법을 기술하시오.

ARM 어셈블리는 x86 과 다르게 복귀 주소를 lr 레지스터에 집어넣는다.
그리고 복귀할 때 주소값을 pc(r15) 레지스터에 넣으면서 복귀한다.
x86 은 스택에 저장했던 복귀 주소를 ip 레지스터에 넣으면서 복귀한다.

12. CISC 와 RISC 아키텍처를 비교하라.

CISC 는 다이 사이즈가 커서 각종 Functional Unit 들을 많이 올릴 수 있는 대신 소비 전력이 높고
RISC 는 다이 사이즈가 작아 보조 유닛들의 수는 적지만
4 byte 고정된 명령어 포맷을 사용하여 간결하고 소비 전력이 적다.
또 CISC 는 Memory 2 Memory 연산이 가능하지만
RISC 는 이것이 불가능한 Load/Store 아키텍처에 해당한다.

13. 컴파일러의 최적화 방지 기법인 volatile asm(":::memory") 라는 기법에 대해 기술하도록 한다.

일반적으로 Compiler 는 Instruction Scheduling 기법을 사용하여
ILP(Instruction Level Parallelism)을 향상시킨다.
그러나 반드시 순서가 지켜져야 하는 경우에는
컴파일러가 멋대로 최적화를 시키면 안 된다.
이 경우에 메모리 베리어를 쳐서 코드가 최적화되지 않게 방지해준다.

14. C++11x 에서 도입 된 initializer_list 에 대해 기술하라.

기존에 C 언어에서 사용하던 가변 인자를
보다 효율적으로 처리하기 위한 C++11 에서 새로 도입 된 문법이다.

15. mov 명령어의 동작 과정에 대해 기술하라.

내용을 복사해서 레지스터에 가져오는 명령어에 해당한다.
상수 값이나 레지스터 값을 복사해서 레지스터로 가져올 수 있다.

16. ARM 의 Load/Store 명령어에 대해 기술하시오.

ldr 명령어는 메모리에서 레지스터로 값을 가져오는 것이고
str 명령어는 레지스터 값을 메모리에 저장하는 명령어다.

17. MCU 에서 PWM 을 제어하는 코드를 작성하였다.
    그러나 모터가 구동되지 않는다면 어떻게 접근해야 할까 ?

우선 오실로스코프를 가져와서 양단의 파형을 찍어본다.
파형이 잘 나오고 있다면 전체 주기나 Duty 비율을 확인하고
파형이 안나온다면 핀 설정이나 프로그램 문제 혹은 보드 고장을 의심해야 한다.

18. 프로그램 최적화를 수행하기 위해 가장 먼저 해야할 일과 가장 나중에 해야할 일은 무엇일까 ?

우선 알고리즘의 대대적인 개편을 수행하는 것이 훨씬 성능 향상이 많이 된다.
이후 보다 성능이 더 필요할 경우 마이크로 아키텍처적인 최적화를 수행 할 필요성이 있다.

19. 리눅스 시스템 프로그래밍에서 IPC 통신을 사용하는 이유를 기술하라.

프로세스는 모두 별도의 독립 된 가상 메모리 공간을 사용하므로
메모리 공유가 이루어지지 않으며 정보를 공유하기 위해서는
IPC 메커니즘인 Mutex, Semaphore, Message Queue, Shared Memory, Pipe 통신, Socket 등이 필요하다.
(참고로 Socket 은 IPC 통신 중 가장 느린 통신에 속하기도 한다)

20. 고 전압 시스템과 저 전압 시스템이 있다.
    이 두 시스템을 상호간 연결하면서 전압을 분리하고 싶다면 어떻게 해야할까 ?

우선 FET 계열의 소자를 사용하는 것이 좋다.
고전압에도 잘 버틸 수 있는 전력용 소자는 MOSFET 에 해당한다.
그래서 모터와 같은 시스템의 구동에도 스위치용 소자로 활용이 되며 응용이 다양하다.
이를 기반으로 Open Collector 회로를 구성하면 두 시스템을 함께 활용하면서 전압은 분리시킬 수 있다.