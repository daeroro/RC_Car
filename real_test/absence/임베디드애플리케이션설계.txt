1. 리눅스의 핵심 철학이 무엇인지 기술하시오.

모든 것은 파일이다.
전자장치 조차도 파일에 해당한다.

2. 리눅스에서 dev/ttyUSB0 를 활성화시키는 방법을 기술하시오.

open() 을 통해서 장치를 읽고 termios 구조체를 적절한 값들로 설정하고
이후에 read(), write() 를 통해서 USB 를 통해 데이터를 전송할 수 있다.

3. 블로킹과 논블로킹에 대해 기술해보시오.

블로킹은 어떤 연산의 순서성을 보장해주고자할 때 사용한다.
반면 논 블로킹은 연산의 순서성보다는 속도를 빠르게 만들고자 할 때 사용한다.

4. 리눅스에서 execve() 시스템 콜을 사용하는 경우 어떤 일이 발생하는지 기술하시오.

특정한 프로세스를 execve() 에서 지정한 프로그램으로 구동시키고자 할 경우에 사용하는 시스템 콜이다.

5. read() 함수의 인자에 대해 기술해보시오.

첫 번째는 읽고자 하는 파일의 디스크립터, 두 번째는 읽은 내용을 가져올 버퍼, 세 번째는 읽을 바이트 수에 해당한다.

6. opendir() 의 용도에 대해 기술하시오.

디렉토리에 대한 포인터를 읽어서 디렉토리에 물려 있는 각각의 디렉토리 엔트리 리스트들을 획득한다.

7. readdir() 의 용도에 대해 기술하시오.

opendir() 로 획득한 디렉토리 엔트리를 실질적으로 읽어서
디렉토리의 이름이나 파일의 이름등등을 획득하는데 사용한다.

8. fork() 를 여러 차례 사용하는 이유가 무엇인가 ?

프로세스 두 개 이상을 만들어서 별도의 작업들을 동시 다발적으로 수행할 수 있도록 만들어주기 위함이다.

9. 리눅스 시스템 프로그래밍과 디바이스 드라이버와의 관계는 어떻게 되는가 ?

디바이스 드라이버는 시스템 프로그래밍에서 사용하는 open, read, write 등을 대체하게 된다.
user 단에서 드라이버 코드를 활용하기 위해서는 이 구조를 파악하고 open, read, write, close 와 같은
시스템 프로그래밍 영역에서의 코드 사용에 익숙해져야 이를 능숙하게 해낼 수 있다.

10. main() 에서 argc, argv 의 용도가 무엇인가 ?

argc 는 인자가 몇 개 들어왔는지
argv 는 각각에 어떠한 문자열이 넘어왔는지를 파악하는데 사용한다.