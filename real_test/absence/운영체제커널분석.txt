1. fork() 를 수행할 경우 무슨 일이 일어나는가 ?

리눅스 커널 내부에 task_struct 구조체가 생성된다.

2. task_struct 구조체의 역할은 무엇인가 ?

유닉스/리눅스 커널의 핵심 철학인 모든 것은 파일이다라는 것을 구현하는 부분이며 프로세스 그 자체임

3. 스레드를 생성하는 System Call 을 사용하면 커널상에 무엇이 만들어지는가 ?

task_struct 구조체가 생성된다.

4. 스레드와 프로세스의 차이점은 무엇인가 ?

프로세스는 여러 스레드들을 이끄는 그룹의 리더이며 스레드는 그룹의 구성원에 해당한다.

5. ctags 와 cscope 를 사용하는 이유는 무엇인가 ?

리눅스 커널과 같이 방대한 소스 코드를 효과적으로 분석하기 위함이다.

6. 리눅스의 스케줄링이나 타이머가 다소 정확하지 못한 이유는 무엇인가 ?

커널 자체 타이머가 있고 이것이 시스템 콜에 의해 연산되어 다시 반환되고
그 사이에 스케쥴링을 처리하고 하는 등 연산 처리에 지연이 발생하여 일정 범위 이하에서는 부정확해짐

7. O(1) 스케쥴러와 O(N) 스케쥴러의 차이를 기술하시오.

O(1) 은 어떤 상황에서도 일정한 값을 유지하며
O(N) 은 데이터의 개수가 많아질수록 시간도 오래걸림(단 데이터가 적으면 빠름)

8. #define 으로 정의된 SYSCALL_DEFINE 에 대해 기술하시오.

리눅스 커널 내부의 시스템 콜을 표현하기 위해 존재함

9. 파일을 open() 하면 커널에서 어떤 일이 발생하는가 ?

해당 파일을 연 프로세스의 task_struct -> files_struct -> file 에 대한 포인터 배열의 숫자가 fd 로 반환됨

10. 리눅스 내부에 있는 가상 파일 시스템의 역할을 기술하시오.

어떤 파일시스템이던 관계 없이 모두 동일한 System Call 을 기반으로 파일에 대한 제어를 수행할 수 있게 해줌